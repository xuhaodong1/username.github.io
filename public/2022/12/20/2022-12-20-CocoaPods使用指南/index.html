<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>CocoaPods使用指南</title><meta name="description" content="不以功利为目的."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'GmOiGEvbpJTlBAXAXlJZrGhRTZOlLBC_CZ2yJaZ_Ktk', 'https://www.nihao.cn/');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="前言对于大多数软件开发团队来说，依赖管理工具必不可少，它能针对开源和私有依赖进行安装与管理，从而提升开发效率，降低维护成本。针对不同的语言与平台，其依赖管理工具也各有不同，例如 npm 管理 Javascript、Gradle 、Maven 管理 Jar 包、pip 管理 Python 包，Bundler、RubyGems 等等。本文聚焦于 iOS 方面，对 CocoaPods 的使用和部分原理进行阐述。

简单易用的 CocoaPods对于 iOSer 来说，CocoaPods 并不陌生，几乎所有的 iOS 工程都会有它的身影。CocoaPods 采用 Ruby 构建，它是 Swift 和 Objective-C Cocoa 项目的依赖管理工具。在 MacOS 上，推荐使用默认的 Ruby 进行安装 (以.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="nihao' Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">nihao's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CocoaPods使用指南</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84-CocoaPods"><span class="toc-text">简单易用的 CocoaPods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod-install-vs-pod-update"><span class="toc-text">pod install vs. pod update</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Podfile-%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83"><span class="toc-text">Podfile 语法规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Root-Options"><span class="toc-text">Root Options</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependencies"><span class="toc-text">Dependencies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Target-configuration"><span class="toc-text">Target configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Workspace"><span class="toc-text">Workspace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sources"><span class="toc-text">Sources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks"><span class="toc-text">Hooks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#podspec-%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83"><span class="toc-text">podspec 语法规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Root"><span class="toc-text">Root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Platform"><span class="toc-text">Platform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-settings"><span class="toc-text">Build settings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-patterns"><span class="toc-text">File patterns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subspecs"><span class="toc-text">Subspecs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi-Platform-support"><span class="toc-text">Multi-Platform support</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">Pod 的开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spec-Repo"><span class="toc-text">Spec Repo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create"><span class="toc-text">Create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Development"><span class="toc-text">Development</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Testing"><span class="toc-text">Testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Release"><span class="toc-text">Release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semantic-Versioning"><span class="toc-text">Semantic Versioning</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CocoaPods-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90"><span class="toc-text">CocoaPods 原理浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CococaPods-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">CococaPods 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod-install-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">pod install 做了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Install-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%88prepare%EF%BC%89"><span class="toc-text">1. Install 环境准备（prepare）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%EF%BC%88resolve-dependencies%EF%BC%89"><span class="toc-text">2. 解决依赖冲突（resolve dependencies）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%EF%BC%88download-dependencies%EF%BC%89"><span class="toc-text">3. 下载依赖文件（download dependencies）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%AA%8C%E8%AF%81-targets%EF%BC%88validate-targets%EF%BC%89"><span class="toc-text">4. 验证 targets（validate targets）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%94%9F%E6%88%90%E5%B7%A5%E7%A8%8B%EF%BC%88Integrate%EF%BC%89"><span class="toc-text">5. 生成工程（Integrate）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%86%99%E5%85%A5%E4%BE%9D%E8%B5%96%EF%BC%88write-lockfiles%EF%BC%89"><span class="toc-text">6. 写入依赖（write lockfiles）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%93%E6%9D%9F%E5%9B%9E%E8%B0%83%EF%BC%88perform-post-install-action%EF%BC%89"><span class="toc-text">7. 结束回调（perform post install action）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CocoaPods-Plugins"><span class="toc-text">CocoaPods + Plugins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%A4%AA%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="toc-text">不太常见概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%97%EF%BC%9A"><span class="toc-text">🔗：</span></a></li></ol></div><div class="column is-9"><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CocoaPods使用指南</h1><header class="my-5"><a href="/tags/CocoaPods"><i class="tag post-item-tag">CocoaPods</i></a><time class="has-text-grey" datetime="2022-12-20T12:57:00.000Z">2022-12-20</time></header><article class="mt-2 post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于大多数软件开发团队来说，依赖管理工具必不可少，它能针对开源和私有依赖进行安装与管理，从而提升开发效率，降低维护成本。针对不同的语言与平台，其依赖管理工具也各有不同，例如 npm 管理 Javascript、Gradle 、Maven 管理 Jar 包、pip 管理 Python 包，Bundler、RubyGems 等等。本文聚焦于 iOS 方面，对 CocoaPods 的使用和部分原理进行阐述。</p>
<span id="more"></span>
<h2 id="简单易用的-CocoaPods"><a href="#简单易用的-CocoaPods" class="headerlink" title="简单易用的 CocoaPods"></a>简单易用的 CocoaPods</h2><p>对于 iOSer 来说，CocoaPods 并不陌生，几乎所有的 iOS 工程都会有它的身影。CocoaPods 采用 Ruby 构建，它是 Swift 和 Objective-C Cocoa 项目的依赖管理工具。在 MacOS 上，推荐使用默认的 Ruby 进行安装 (以下操作均在 CocoaPods 1.10.1、Ruby 2.7.2 进行)：</p>
<pre><code class="shell">sudo gem install cocoapods
</code></pre>
<p>如果安装成功，便可以使用 pod 的相关命令了。针对一个简单的项目来说，只需三步便可引入其他的依赖：</p>
<ol>
<li>创建 Podfile 文件( CocoaPods 提供了 pod init 命令创建)</li>
<li>对 Podfile 文件进行编写，添加依赖的库，版本等信息。</li>
<li>在命令行执行 <code>pod install</code> 命令</li>
</ol>
<p>顺利的话，这时在项目目录下会出现以下文件：</p>
<ul>
<li>.xcworkspace：CocoaPods 将项目分为了主工程与依赖工程(Pods)。与 .xcodeproj 相比 .xcworkspace 对于管理多个项目的能力更强，你也可以将复杂的大型应用转换为以 .xcworkspace 构建的多个兄弟项目，从而更轻松的维护和共享功能。</li>
<li>Podfile.lock：记录并跟踪依赖库版本，将依赖库锁定于某个版本。</li>
<li>Pods 文件夹：存放依赖库代码。</li>
<li>Pods/Manifest.lock：每次 <code>pod install</code> 时创建的 Podfile.lock 的副本，用于比较这两个文件。一般来说，Podfile.lock 会纳入版本控制管理，而 Pods 文件夹则不会纳入版本控制变更；这意味着 Podfile.lock 表示项目应该依赖的库版本信息，而 Manifest.lock 则代表本地 Pods 的依赖库版本信息。在 pod install 后会将脚本插入到 Build Phases，名为 <code>[CP] Check Pods Manifest.lock</code>，从而保证开发者在运行 app 之前能够更新 Pods，以确保代码是最新的。</li>
</ul>
<h2 id="pod-install-vs-pod-update"><a href="#pod-install-vs-pod-update" class="headerlink" title="pod install vs. pod update"></a>pod install vs. pod update</h2><ul>
<li><code>pod install</code>：在每一次编辑 Podfile 以添加、更新或删除 pod 时使用。它会下载并安装新的 Pod，并将其版本信息写入 Podfile.lock 中。</li>
<li><code>pod outdated</code>：列出所有比 Podfile.lock 中当前记录的版本 newer 版本的 pod。</li>
<li><code>pod update [PODNAME]</code>：CocoaPods 会查找 newer 版本的 PODNAME，同时将 pod 更新到可能的最新版本(须符合 Podfile 限制)。若没有 PODNAME，则会将每一个 pod 更新到可能的最新版本。</li>
</ul>
<p>一般来说，每次编辑 Podfile 时使用 <code>pod install</code>，仅在需要更新某个 pod 版本(所有版本)时才使用 pod update。同时，需提交 Podfile.lock 文件而不是 Pods 文件夹来达到同步所有 pod 版本的目的。</p>
<p>ps: newer 代表更加新的，若采用中文理解起来比较别扭。</p>
<h2 id="Podfile-语法规范"><a href="#Podfile-语法规范" class="headerlink" title="Podfile 语法规范"></a>Podfile 语法规范</h2><p>Podfile 描述了一个或多个 Xcode 项目的 target 依赖关系，它是一种 DSL，了解它对我们使用好 CocoaPods 是一个必不可少的步骤。下面列出其相关的语法规范：</p>
<h3 id="Root-Options"><a href="#Root-Options" class="headerlink" title="Root Options"></a>Root Options</h3><p>install：指定 CocoaPods 安装 Podfile 时使用的安装方法和选项。如：</p>
<pre><code class="ruby">install! 'cocoapods',
         :deterministic_uuids =&gt; false,
         :integrate_targets =&gt; false
</code></pre>
<ul>
<li><code>:clean</code>：根据 podspec 和项目支持平台的指定，清理所有不被 pod 使用的文件，默认为 true。</li>
<li><code>:deduplicate_targets</code>：是否对 pod target 进行重复数据删除，默认为 true。</li>
<li><code>:deterministic_uuids</code>：创建 pod project 是否产生确定性 UUID，默认为 true。</li>
<li><code>:integrate_targets</code>：是否继承到用户项目中，为 false 会将 Pod 下载并安装到到 project_path/Pods 目录下，默认为 true。</li>
<li><code>:lock_pos_sources</code>：是否锁定 pod 的源文件，当 Xcode 尝试修改时会提示解锁文件，默认为 true。</li>
<li><code>:warn_for_multiple_pod_sources</code>：当多个 source 包含同名同版本 pod 时是否发出警告，默认为 true。</li>
<li><code>:warn_for_unused_master_specs_repo</code>：如果没有明确指出 master specs repo 的 git 是否发出警告，默认为 true。</li>
<li><code>:share_schemes_for_development_pods</code>：是否为开发中的 pod 分享 schemes，默认为 false。</li>
<li><code>:disable_input_output_paths</code>：是否禁用 CocoaPods 脚本阶段的输入输出路径（Copy Frameworks 和 Copy Resources），默认为 false。</li>
<li><code>:preserve_pod_file_structure</code>：是否保留所有 pod 的文件结构，默认为 false。</li>
<li><code>:generate_multiple_pod_projects</code>：是否为每一个 pod target 生成 一个 project，生成与 Pods/Pods 文件夹中，默认为 false。</li>
<li><code>:incremental_installation</code>：仅对自上次安装的 target 与其关联的 project 的变更部分进行重新生成，默认为 false。</li>
<li><code>:skip_pods_project_generation</code>：是否跳过生成 Pods.xcodeproj 并仅进行依赖项解析与下载，默认为 false。</li>
</ul>
<p>ensure_bundler!：当 bundler 版本不匹配时发出警告。</p>
<pre><code class="ruby">ensure_bundler! '~&gt; 2.0.0'
</code></pre>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p><strong>pod</strong>：指定项目的依赖项</p>
<ul>
<li>依赖版本控制：=、&gt;、&gt;=、&lt;、&lt;= 为字面意思；~&gt; 0.1.2 表示 0.1.2 &lt;= currVersion &lt; 0.2 之间的符合要求的最新版本版本。</li>
<li>Build configurations：默认依赖安装在所有的构建配置中，但也可仅在指定构建配置中启用。</li>
<li>Modular Headers：用于将 pod 转换为 module 以支持模块，这时在 Swift 中可以不用借助 <code>bridging-header</code> 桥接就可以直接导入，简化了 Swift 引用 Objective-C 的方式；也可以采用 <code>use_modular_headers!</code> 进行全局的变更。</li>
<li>Source：指定具有依赖项的源，同时会忽略全局源。</li>
<li>Subspecs：默认会安装所有的 subspecs，但可制定安装某些 subspecs。</li>
<li>Test Specs：默认不会安装 test specs，但可选择性安装 test specs。</li>
<li>Local path：将开发的 pod 与其客户端一起使用，可采用 path。</li>
<li>指定某个特殊或者更为先进的 pod 版本</li>
</ul>
<pre><code class="ruby"># 依赖版本控制
pod 'Objection', '~&gt; 0.9' 
# Build configurations
pod 'PonyDebugger', :configurations =&gt; ['Debug', 'Beta'] 
# Modular Headers
pod 'SSZipArchive', :modular_headers =&gt; true 
# Source
pod 'PonyDebugger', :source =&gt; 'https://github.com/CocoaPods/Specs.git'
# Subspecs
pod 'QueryKit', :subspecs =&gt; ['Attribute', 'QuerySet'] 
# Test Specs
pod 'AFNetworking', :testspecs =&gt; ['UnitTests', 'SomeOtherTests']
# Local path
pod 'AFNetworking', :path =&gt; '~/Documents/AFNetworking'
# 指定某个特殊或者更为先进的 Pod 版本
pod 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :branch =&gt; 'dev'
pod 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :tag =&gt; '0.7.0'
pod 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :commit =&gt; '082f8319af'
# 指定某个 podspec
pod 'JSONKit', :podspec =&gt; 'https://example.com/JSONKit.podspec'
</code></pre>
<p><strong>inherit</strong>：设置当前 target 的继承模式。</p>
<p><code>:complete</code> 继承父级 target 的所有行为，<code>:none</code> 不继承父级 target 的任何行为，<code>:search_paths</code> 仅继承父级的搜索路径。</p>
<pre><code class="ruby">target 'App' do
  target 'AppTests' do
    inherit! :search_paths
  end
end
</code></pre>
<p><strong>target</strong>：与 Xcode 中的 target 相对应，block 中是 target 的依赖项。</p>
<p>默认情况下，target 包含在父级 target 定义的依赖项，也即 <code>inherit!</code> 为 <code>:complete</code>。关于 <code>:complete</code> 和 <code>:search_paths</code>，<code>:complete</code> 会拷贝父级 target 的 pod 副本，而 <code>:search_paths</code> 则只进行 <code>FRAMEWORK_SEARCH_PATHS</code> 和 <code>HEADER_SEARCH_PATHS</code> 的相关拷贝，具体可通过比对 Pods/Target Support Files 的相关文件得以验证，一般在 <code>UnitTests</code> 中使用，以减少多余的 <code>install_framework</code> 过程。</p>
<pre><code class="ruby">target 'ShowsApp' do
  pod 'ShowsKit'
  # 拥有 ShowsKit 和 ShowTVAuth 的拷贝
  target 'ShowsTV' do
    pod 'ShowTVAuth'
  end
  # 拥有 Specta 和 Expecta 的拷贝
  # 并且能够通过 ShowsApp 进行访问 ShowsKit, 相当于 ShowsApp 是 ShowsTests 的宿主APP
  target 'ShowsTests' do
    inherit! :search_paths
    pod 'Specta'
    pod 'Expecta'
  end
end
</code></pre>
<p><strong>abstract_target</strong>：定义 <code>abstract_target</code>，方便 target 进行依赖继承，在 CocoaPods 1.0 版本之前为 <code>link_with</code>。</p>
<pre><code class="ruby">abstract_target 'Networking' do
  pod 'AlamoFire'

  target 'Networking App 1'
  target 'Networking App 2'
end
</code></pre>
<p><strong>abstract</strong>：表示当前 target 是抽象的，不会链接到 Xcode 的 target 中。</p>
<p><strong>script_phase</strong>：添加脚本阶段。</p>
<p>在执行完 <code>pod install</code> 之后 CocoaPods 会将脚本添加到对应的 <code>target build phases</code>。</p>
<pre><code class="ruby">target 'App' do
    script_phase {
        :name =&gt; 'scriptName' # 脚本名称,
        :script =&gt; 'echo "nihao"' # 脚本内容,
        :execution_position =&gt; :before_compile / :after_compile
        :shell_path =&gt; '/usr/bin/ruby' # 脚本路径
        :input_files =&gt; ['/input/filePath'], # 输入文件
        :output_files =&gt; ['/outpput/filePath'] # 输出文件
    }
end
</code></pre>
<h3 id="Target-configuration"><a href="#Target-configuration" class="headerlink" title="Target configuration"></a>Target configuration</h3><p><strong>platform</strong>：指定其构建平台。</p>
<p>默认值为 iOS 4.3、OSX 10.6、tvOS 9.0 和 watchOS 2.0。CocoaPods 1.0 之前的版本为 xcodeproj</p>
<pre><code class="ruby">platform :ios, '4.0'
</code></pre>
<p><strong>project</strong>：指定包含 target 的 Xcode project。这一般在 workspace 存在多个 xcode project 中使用：</p>
<pre><code class="ruby"># 在 FastGPS Project 中可以找到一个名为 MyGPSApp 的 target
target 'MyGPSApp' do
  project 'FastGPS'
  ...
end
</code></pre>
<p><strong>inhibit_all_warnings</strong>!：禁止所有警告。</p>
<p>如果针对单个 Pod，则可以采用：</p>
<pre><code class="ruby">pod 'SSZipArchive', :inhibit_warnings =&gt; true
pod 'SSZipArchive', :inhibit_warnings =&gt; true
</code></pre>
<p><strong>user_modular_headers</strong>!：将所有 Pod 模块化。</p>
<p>如果针对单个 Pod，则可以采用：</p>
<pre><code class="ruby">pod 'SSZipArchive', :modular_headers =&gt; true
pod 'SSZipArchive', :modular_headers =&gt; false
</code></pre>
<p><strong>user_frameworks</strong>!：采用 framework 而不是 .a 文件的静态库。</p>
<p>可以通过 <code>:linkage</code> 指定使用静态库还是动态库：</p>
<pre><code class="ruby">use_frameworks！:linkage =&gt; :dynamic / :static
</code></pre>
<p><strong>supports_swift_versions</strong>：指定 target definition 支持的 swift 版本要求</p>
<pre><code class="ruby">supports_swift_versions '&gt;= 3.0', '&lt; 4.0'
</code></pre>
<h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p><strong>workspace</strong>：指定包含所有项目的 Xcode workspace。</p>
<pre><code class="ruby">workspace 'MyWorkspace'
</code></pre>
<h3 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h3><p><strong>sources</strong>：Podfile 从指定的源列表中进行检索。sources 默认存储在 ~/.cocoapods/repos 中，是全局的而非按 target definition 存储。当有多个相同的 Pod 时，优先采用检索到的 Pod 的第一个源，因此当指定另一个来源时，则需显示指定 CocoaPods 的源。</p>
<pre><code class="ruby">source 'https://github.com/artsy/Specs.git'
source 'https://github.com/CocoaPods/Specs.git'
</code></pre>
<h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p><strong>plugin</strong>：指定在安装期间使用的插件。</p>
<pre><code class="ruby">plugin 'cocoapods-keys', :keyring =&gt; 'Eidolon'
plugin 'slather'
</code></pre>
<p><strong>pre_install</strong>：在下载后和在安装 Pod 前进行更改。</p>
<pre><code class="ruby">pre_install do |installer|
  # Do something fancy!
end
</code></pre>
<p><strong>pre_integrate</strong>：在 project 写入磁盘前进行更改。</p>
<pre><code class="ruby">pre_integrate do |installer|
  # perform some changes on dependencies
end
</code></pre>
<p><strong>post_install</strong>：对生成 project 写入磁盘前进行最后的修改。</p>
<pre><code class="ruby">post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['GCC_ENABLE_OBJC_GC'] = 'supported'
    end
  end
end
</code></pre>
<p><strong>post_integrate</strong>：在 project 写入磁盘后进行最后更改。</p>
<pre><code class="ruby">post_integrate do |installer|
  # some change after project write to disk
end
</code></pre>
<h2 id="podspec-语法规范"><a href="#podspec-语法规范" class="headerlink" title="podspec 语法规范"></a>podspec 语法规范</h2><p>podspec = pod Specification，意为 pod 规范，它是一个 Ruby 文件。包含了 Pod 的库版本详细信息，例如应从何处获取源、使用哪些文件、要应用构建设置等信息；也可以看作该文件是整个仓库的索引文件，了解它对我们知道 Pod 库是如何组织、运作的提供了很大帮助。podspec 的 DSL 提供了极大的灵活性，文件可通过 <code>pod spec create</code> 创建。</p>
<h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>必需</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>pod 名称</td>
<td>required</td>
</tr>
<tr>
<td><code>version</code></td>
<td>pod 版本，遵循语义化版本控制</td>
<td>required</td>
</tr>
<tr>
<td><code>swift_version</code></td>
<td>支持的 Swift 版本</td>
<td></td>
</tr>
<tr>
<td><code>cocoapods_version</code></td>
<td>支持的 CocoaPods 版本</td>
<td></td>
</tr>
<tr>
<td><code>authors</code></td>
<td>pod 维护者的姓名和电子邮件，用“, ”进行分割</td>
<td>required</td>
</tr>
<tr>
<td><code>license</code></td>
<td>pod 的许可证</td>
<td>required</td>
</tr>
<tr>
<td><code>homepage</code></td>
<td>pod 主页的 URL</td>
<td>required</td>
</tr>
<tr>
<td><code>source</code></td>
<td>源地址，即源文件的存放地址，支持多种形式源</td>
<td>required</td>
</tr>
<tr>
<td><code>summary</code></td>
<td>pod 的简短描述</td>
<td>required</td>
</tr>
<tr>
<td><code>prepare_command</code></td>
<td>下载 pod 后执行的 bash 脚本</td>
<td></td>
</tr>
<tr>
<td><code>static_framework</code></td>
<td>是否采用静态 framework 分发</td>
<td></td>
</tr>
<tr>
<td><code>deprecated</code></td>
<td>该库是否已被弃用</td>
<td></td>
</tr>
<tr>
<td><code>deprecated_in_favor_of</code></td>
<td>该库名称已被弃用，取而代之</td>
<td></td>
</tr>
</tbody></table>
<pre><code class="ruby">Pod::Spec.new do |s|
  s.name             = 'CustomPod'
  s.version          = '0.1.0'
  s.summary          = 'A short description of CustomPod.'
  s.swift_versions   = ['3.0', '4.0', '4.2']
  s.cocoapods_version  =  '&gt;= 0.36'
  s.author           = { 'nihao' =&gt; 'XXXX@qq.com' }
  s.license          = { :type =&gt; 'MIT', :file =&gt; 'LICENSE' }
  s.homepage         = 'https://github.com/XXX/CustomPod'
# Supported Key
# :git=&gt; :tag, :branch, :commit,:submodules
# :svn=&gt; :folder, :tag,:revision
# :hg=&gt;:revision
# :http=&gt; :flatten, :type, :sha256, :sha1,:headers
  s.source           = { :git =&gt; 'https://github.com/XX/CustomPod.git', :tag =&gt; s.version.to_s }
  s.prepare_command  =  'ruby build_files.rb'
  s.static_framework = true
  s.deprecated       = true
  s.deprecated_in_favor_of  =  'NewMoreAwesomePod'
end
</code></pre>
<h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><p><strong>platform</strong>：pod 支持的平台，留空意味着 pod 支持所有平台。当支持多平台时应该用 <code>deployment_target</code> 代替。</p>
<pre><code class="ruby">spec.platform = :osx, '10.8'
</code></pre>
<p><strong>deployment_target</strong>：允许指定支持此 pod 的多个平台，为每个平台指定不同的部署目标。</p>
<pre><code class="ruby">spec.ios.deployment_target = '6.0'
spec.osx.deployment_target = '10.8'
</code></pre>
<h3 id="Build-settings"><a href="#Build-settings" class="headerlink" title="Build settings"></a>Build settings</h3><p><strong>dependency</strong>：基于其他 pods 或子规范的依赖</p>
<pre><code class="ruby">spec.dependency 'AFNetworking', '~&gt; 1.0', :configurations =&gt; ['Debug']
</code></pre>
<p><strong>info_plist</strong>：加入到生成的 Info.plist 的键值对，会对 CocoaPods 生成的默认值进行覆盖。仅对使用 framework 的框架有影响，对静态库无效。对于应用规范，这些值将合并到应用程序主机的 <code>Info.plist</code>；对于测试规范，这些值将合并到测试包的 Info.plist。</p>
<pre><code class="ruby">spec.info_plist = {
  'CFBundleIdentifier' =&gt; 'com.myorg.MyLib',
  'MY_VAR' =&gt; 'SOME_VALUE'
}
</code></pre>
<p><strong>requires_arc</strong>：允许指定哪些 source_files 采用 ARC，不使用 ARC 的文件将具有 <code>-fno-objc-arc</code> 编译器标志</p>
<pre><code class="ruby">spec.requires_arc = false
spec.requires_arc = 'Classes/Arc'
spec.requires_arc = ['Classes/*ARC.m', 'Classes/ARC.mm']
</code></pre>
<p><strong>frameworks</strong>：使用者 target 需要链接的系统框架列表</p>
<pre><code class="ruby">spec.ios.framework = 'CFNetwork'
spec.frameworks = 'QuartzCore', 'CoreData'
</code></pre>
<p><strong>weak_frameworks</strong>：使用者 target 需要弱链接的框架列表</p>
<pre><code class="swift">spec.weak_framework = 'Twitter'
spec.weak_frameworks = 'Twitter', 'SafariServices'
</code></pre>
<p><strong>libraries</strong>：使用者 target 需要链接的系统库列表</p>
<pre><code class="ruby">spec.ios.library = 'xml2'
spec.libraries = 'xml2', 'z'
</code></pre>
<p><strong>compiler_flags</strong>：应传递给编译器的 flags</p>
<pre><code class="ruby">spec.compiler_flags = '-DOS_OBJECT_USE_OBJC=0', '-Wno-format'
</code></pre>
<p><strong>pod_target_xcconfig</strong>：将指定 flag 添加到最终 pod 的 xcconfig 文件</p>
<pre><code class="ruby">spec.pod_target_xcconfig = { 'OTHER_LDFLAGS' =&gt; '-lObjC' }
</code></pre>
<p><strong>user_target_xcconfig</strong>：🙅 将指定 flag 添加到最终聚合的 target 的 xcconfig，不推荐使用此属性，因为会污染用户的构建设置，可能会导致冲突。</p>
<pre><code class="ruby">spec.user_target_xcconfig = { 'MY_SUBSPEC' =&gt; 'YES' }
</code></pre>
<p><strong>prefix_header_contents</strong>：🙅 在 Pod 中注入的预编译内容，不推荐使用此属性，因为其会污染用户或者其他库的预编译头。</p>
<pre><code class="ruby">spec.prefix_header_contents = '#import &lt;UIKit/UIKit.h&gt;', '#import &lt;Foundation/Foundation.h&gt;'
</code></pre>
<p><strong>prefix_header_file</strong>：预编译头文件，false 表示不生成默认的 CocoaPods 的与编译头文件。🙅 不推荐使用路径形式，因为其会污染用户或者其他库的预编译头。</p>
<pre><code class="ruby">spec.prefix_header_file = 'iphone/include/prefix.pch'
spec.prefix_header_file = false
</code></pre>
<p><strong>module_name</strong>：生成的 framrwork / clang module 使用的名称，而非默认名称。</p>
<pre><code class="ruby">spec.module_name = 'Three20'
</code></pre>
<p><strong>header_dir</strong>：存储头文件的目录，这样它们就不会被破坏。</p>
<pre><code class="ruby">spec.header_dir = 'Three20Core'
</code></pre>
<p><strong>header_mappings_dir</strong>：用于保留头文件文件夹的目录。如未提供，头文件将被碾平。</p>
<pre><code class="ruby">spec.header_mappings_dir = 'src/include'
</code></pre>
<p><strong>script_phases</strong>：该属性允许定义脚本在 pod 编译时执行，其作为 <code>xcode build</code> 命令的一部分执行，还可以利用编译期间所设置的环境变量。</p>
<pre><code class="ruby">spec.script_phases = [
    { :name =&gt; 'Hello World', :script =&gt; 'echo "Hello World"' },
    { :name =&gt; 'Hello Ruby World', :script =&gt; 'puts "Hello World"', :shell_path =&gt; '/usr/bin/ruby' },
  ]
</code></pre>
<h3 id="File-patterns"><a href="#File-patterns" class="headerlink" title="File patterns"></a>File patterns</h3><p>文件模式指定了库的所有文件管理方式，如源代码、头文件、framework、libaries、以及各种资源。其文件模式通配符形式可参考 <a target="_blank" rel="noopener" href="https://guides.cocoapods.org/syntax/podspec.html#group_file_patterns">LINK</a>。</p>
<p><strong>source_files</strong>：指定源文件</p>
<pre><code class="ruby">spec.source_files = 'Classes/**/*.{h,m}', 'More_Classes/**/*.{h,m}'
</code></pre>
<p><strong>public_header_files</strong>：指定公共头文件，这些头文件与源文件匹配，并生成文档向用户提供。如果未指定，则将 source_files 中的所有头文件都包含生成。</p>
<pre><code class="ruby">spec.public_header_files = 'Headers/Public/*.h'
</code></pre>
<p><strong>project_header_files</strong>：指定项目头文件，与公共头文件相对应，以排除不应向用户项目公开且不应用于生成文档的标头，且不会出现在构建目录中。</p>
<pre><code class="ruby">spec.project_header_files = 'Headers/Project/*.h'
</code></pre>
<p><strong>private_header_files</strong>：私有头文件，与公共头文件对应，以排除不应向用户项目公开且不应用于生成文档的标头，这些头文件会出现在产物中的 PrivateHeader 文件夹中。</p>
<pre><code class="ruby">spec.private_header_files = 'Headers/Private/*.h'
</code></pre>
<p><strong>vendered_frameworks</strong>：pod 附加的 framework 路径</p>
<pre><code class="ruby">spec.ios.vendored_frameworks = 'Frameworks/MyFramework.framework'
spec.vendored_frameworks = 'MyFramework.framework', 'TheirFramework.xcframework'    
</code></pre>
<p><strong>vendered_libraries</strong>：pod 附加的 libraries 路径</p>
<pre><code class="ruby">spec.ios.vendored_library = 'Libraries/libProj4.a'
spec.vendored_libraries = 'libProj4.a', 'libJavaScriptCore.a'
</code></pre>
<p><strong>on_demand_resources</strong>：根据 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2015/214/">Introducing On demand Resources</a> 按需加载资源，不推荐与主工程共享标签，默认类别为 <code>category =&gt; :download_on_demand</code></p>
<pre><code class="ruby">s.on_demand_resources = {
  'Tag1' =&gt; { :paths =&gt; ['file1.png', 'file2.png'], :category =&gt; :download_on_demand }
}
s.on_demand_resources = {
  'Tag1' =&gt; { :paths =&gt; ['file1.png', 'file2.png'], :category =&gt; :initial_install }
}
</code></pre>
<p><strong>resources</strong>：为 pod 构建的 bundle 的名称和资源文件，其中 key 为 bundle 名称，值代表它们应用的文件模式。</p>
<pre><code class="ruby">spec.resource_bundles = {
    'MapBox' =&gt; ['MapView/Map/Resources/*.png'],
    'MapBoxOtherResources' =&gt; ['MapView/Map/OtherResources/*.png']
}
</code></pre>
<p><strong>exclude_files</strong>：排除的文件模式列表</p>
<pre><code class="ruby">spec.ios.exclude_files = 'Classes/osx'
spec.exclude_files = 'Classes/**/unused.{h,m}'
</code></pre>
<p><strong>preserve_paths</strong>：下载后不应删除的文件。默认情况下，CocoaPods 会删除与其他文件模式不匹配的所有文件</p>
<pre><code class="ruby">spec.preserve_path = 'IMPORTANT.txt'
spec.preserve_paths = 'Frameworks/*.framework'
</code></pre>
<p><strong>module_map</strong>：pod 继承为 framework 时使用的模块映射文件，默认为 true，CocoaPods 根据 公共头文件创建 module_map 文件。</p>
<pre><code class="ruby">spec.module_map = 'source/module.modulemap'
spec.module_map = false
</code></pre>
<h3 id="Subspecs"><a href="#Subspecs" class="headerlink" title="Subspecs"></a>Subspecs</h3><p><strong>subspec</strong>：子模块的规范；实行双重继承：specs 自动继承所有 subspec 作为依赖项(除非指定默认 spec)；subspec 继承了父级的属性；</p>
<pre><code class="ruby"># 采用不同源文件的 Specs, CocoaPods 自动处理重复引用问题
subspec 'Twitter' do |sp|
  sp.source_files = 'Classes/Twitter'
end

subspec 'Pinboard' do |sp|
  sp.source_files = 'Classes/Pinboard'
end

# 引用其他子规范
s.subspec "Core" do |ss|
    ss.source_files  = "Sources/Moya/", "Sources/Moya/Plugins/"
    ss.dependency "Alamofire", "~&gt; 5.0"
    ss.framework  = "Foundation"
  end

  s.subspec "ReactiveSwift" do |ss|
    ss.source_files = "Sources/ReactiveMoya/"
    ss.dependency "Moya/Core"
    ss.dependency "ReactiveSwift", "~&gt; 6.0"
  end

  s.subspec "RxSwift" do |ss|
    ss.source_files = "Sources/RxMoya/"
    ss.dependency "Moya/Core"
    ss.dependency "RxSwift", "~&gt; 5.0"
  end
end

# 嵌套子规范
Pod::Spec.new do |s|
  s.name = 'Root'

  s.subspec 'Level_1' do |sp|
    sp.subspec 'Level_2' do |ssp|
    end
  end
end
</code></pre>
<p><strong>default_subspecs</strong>：默认子规范数组名称，不指定将全部子规范作为默认子规范，<code>:none</code> 表示不需要任何子规范。</p>
<pre><code class="ruby">spec.default_subspec = 'Core'
spec.default_subspecs = 'Core', 'UI'
spec.default_subspecs = :none    
</code></pre>
<p><strong>scheme</strong>：用以给指定 scheme configuration 添加拓展</p>
<pre><code class="ruby">spec.scheme = { :launch_arguments =&gt; ['Arg1'] }
spec.scheme = { :launch_arguments =&gt; ['Arg1', 'Arg2'], :environment_variables =&gt; { 'Key1' =&gt; 'Val1'} }
</code></pre>
<p><strong>test_spec</strong>：测试规范，在 1.8 版本支持。可参考：<a target="_blank" rel="noopener" href="https://blog.cocoapods.org/CocoaPods-1.8.0-beta/">CocoaPods 1.8 Beta</a></p>
<p><strong>requires_app_host</strong>：是否需要宿主 APP 运行测试，仅适用于测试规范。</p>
<p><strong>app_host_name</strong>：必要时作用于应用程序的应用程序规范名称</p>
<p><strong>app_spec</strong>：宿主 APP 规范</p>
<pre><code class="ruby">Pod::Spec.new do |s|
  s.name         = 'CannonPodder'
  s.version      = '1.0.0'

  # ...rest of attributes here

  s.app_spec 'DemoApp' do |app_spec|
    app_spec.source_files = 'DemoApp/**/*.swift'
    # Dependency used only by this app spec.
    app_spec.dependency 'Alamofire'
  end

  s.test_spec 'Tests' do |test_spec|
    test_spec.requires_app_host = true
    # Use 'DemoApp' as the app host.
    test_spec.app_host_name = 'CannonPodder/DemoApp'

    # ...rest of attributes here

    # This is required since 'DemoApp' is specified as the app host.
    test_spec.dependency 'CannonPodder/DemoApp'
  end
end
</code></pre>
<h3 id="Multi-Platform-support"><a href="#Multi-Platform-support" class="headerlink" title="Multi-Platform support"></a>Multi-Platform support</h3><p>存储特定于某一个平台的值，分别为 ios、osx、macOS、tvos、watchos：</p>
<pre><code class="ruby">spec.resources = 'Resources/**/*.png'
spec.ios.resources = 'Resources_ios/**/*.png'
</code></pre>
<h2 id="Pod-的开发流程"><a href="#Pod-的开发流程" class="headerlink" title="Pod 的开发流程"></a>Pod 的开发流程</h2><p>了解完 Podfile 和 podspec 的相关的规范之后，那么开发自己的 pod 应该是一件驾轻就熟的事。</p>
<h3 id="Spec-Repo"><a href="#Spec-Repo" class="headerlink" title="Spec Repo"></a>Spec Repo</h3><p>Spec Repo 是 podspec 的仓库，即是存储相关的 podspec 文件的地方。本地源存储于 ~/.cocoapods/repos中，它从 git 上拉取并完全保留目录结构。可以发现， Master Specs Repo 的现在目录结构有些特殊；以往版本的 Master Spec Repo 是完全在同一目录下的，但若大量文件在同一目录中会导致了 <a target="_blank" rel="noopener" href="https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935">Github 下载慢</a> 的问题。为解决这个问题，采用散列表形式处理。具体方式为对名称进行 MD5 计算得到散列值，取前三位作为目录前缀，以对文件分散化。初次之外，CocoaPods 后续还采用 CDN 以及 trunk 进一步加快下载速度，有兴趣可以参考 <a target="_blank" rel="noopener" href="http://chuquan.me/2022/01/07/source-analyze-principle/">CocoaPods Source 管理机制</a>。</p>
<p>如：<code>md5("CJFoundation") =&gt; 044d913fdd5a52b303222c357521f744</code>；<code>CJFoundation</code> 则在 /Specs/0/4/4 目录中</p>
<p><img src="https://raw.githubusercontent.com/xuhaodong1/resource/master/image-20221215171557476.png" alt="image-20221215171557476"></p>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>只需利用  <code>pod lib create [PodName]</code> 命令便可以快速创建一个自己的 pod 。填写好使用平台、使用语言、是否包含 Demo、测试框架等信息，CocoaPods 会从默认的 Git 地址中拉取一份 pod 模版，同时也可以通过 <code>--template-url=URL</code> 指定模版地址。在执行完后，整个文件结构如下：</p>
<pre><code class="swift">tree CustomPod -L 2

CustomPod
├── CustomPod
│   ├── Assets // 存放资源文件
│   └── Classes
│       └── RemoveMe.[swift/m] // 单一文件以确保最初编译工作
├── CustomPod.podspec // Pod 的 spec 文件, 是一个 Pod 依赖的索引以及规范信息
├── Example // 用作演示/测试的示例项目
│   ├── CustomPod
│   ├── CustomPod.xcodeproj
│   ├── CustomPod.xcworkspace
│   ├── Podfile
│   ├── Podfile.lock
│   ├── Pods
│   └── Tests
├── _Pods.xcodeproj -&gt; Example/Pods/Pods.xcodeproj // 指向 Pods 项目的以获得 Carthage 支持
├── LICENSE // 许可证
└── README.md  // 自述文件
</code></pre>
<h3 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h3><p>将源文件和资源分别放入 Classes / Assets 文件夹中，或者按你喜欢的方式组织文件，并在 podspec 文件中编辑相应项。如果你有任何想使用的配置项，可参考前面的podsepc 语法规范 。</p>
<p>一般来说，开发 Pod 一般都是作为本地 Pod 被其他 Project 所依赖进行开发，无论是使用 example 文件夹的 project 或者其他的 Project。</p>
<p><code>pod 'Name', :path =&gt; '~/CustomPod/'</code></p>
<h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>通过 <code>pod lib lint</code> 以验证 Pod 仓库的使用是否正常。</p>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>前面提到过 podspec 可以看作是整个仓库的索引文件，有了这个文件也就能组织起一个 Pod。因此官方的源以及私有源都只需要 podspec 即可，而其他文件则应推送到 podspec 中 source 中指定仓库，这个仓库应该是你自创建的。</p>
<p>在准备发布推送源代码时，需要更新版本号以及在 git 上打上 tag，这是为了进行版本号匹配，因为默认情况下的 podspec 文件中：</p>
<pre><code class="ruby">s.source = { :git =&gt; 'https://github.com/XXX/CustomPod.git', :tag =&gt; s.version.to_s }
</code></pre>
<p>可能你的工作流操作如下：</p>
<pre><code class="shell">$ cd ~/code/Pods/NAME
$ edit NAME.podspec
# set the new version to 0.0.1
# set the new tag to 0.0.1
$ pod lib lint
$ git add -A &amp;&amp; git commit -m "Release 0.0.1."
$ git tag '0.0.1'
$ git push --tags
</code></pre>
<p>存有几种方式推送 podspec 文件：</p>
<ol>
<li>推送到<a target="_blank" rel="noopener" href="https://github.com/CocoaPods/Specs.git">公共仓库</a>，需要用到的 trunk 子命令，更多可以参考 <a target="_blank" rel="noopener" href="https://guides.cocoapods.org/making/getting-setup-with-trunk">Getting setup with Trunk</a>：</li>
</ol>
<pre><code class="shell"># 通过电子邮箱进行注册
pod trunk register orta@cocoapods.org 'Orta Therox' --description='macbook air' 
# 将指定podspec文件推送到公共仓库中
pod trunk push [NAME.podspec] 
# 添加其他人作为协作者
pod trunk add-owner ARAnalytics kyle@cocoapods.org 
</code></pre>
<ol start="2">
<li>推送到私有源，例如 <a target="_blank" rel="noopener" href="https://github.com/artsy/Specs">Artsy/Specs</a>，需要用到 repo 子命令，更多可以参考 <a target="_blank" rel="noopener" href="https://guides.cocoapods.org/making/private-cocoapods">Private Pods</a>：</li>
</ol>
<pre><code class="shell"># 将私有源地址添加到本地
pod repo add REPO_NAME SOURCE_URL 
# 检查私有源是否安装成功并准备就绪
cd ~/.cocoapods/repos/REPO_NAME
pod repo lint .
# 将Pod的podspec添加到指定REPO_NAME中
pod repo push REPO_NAME SPEC_NAME.podspec
</code></pre>
<ol start="3">
<li>不推送到任何源中，若能存在以 URL 方式检索到 podspec文件，则可用该 URL，一般采用仓库地址，例如：</li>
</ol>
<pre><code class="ruby">pod 'AFNetworking', :git =&gt; 'https://github.com/XXX/CustomPod.git'
</code></pre>
<h3 id="Semantic-Versioning"><a href="#Semantic-Versioning" class="headerlink" title="Semantic Versioning"></a>Semantic Versioning</h3><p>语义化版本控制顾名思义是一种语义上的版本控制，它不要求强制遵循，只是希望开发者能够尽量遵守。如果库之间依赖关系过高，可能面临版本控制被锁死的风险（可能需要对每一个依赖库改版才能完成某次升级）；如果库之间依赖关系过于松散，又将无法避免版本的混乱（可能库兼容性不再能支持以往版本），语义化版本控制正是作为这个问题的解决方案之一。无论在 CocoaPods 中，还是 Swift Packager Manager 上，官方都希望库开发者的的版本号能遵循这一原则：</p>
<p>例如，给定版本号 <code>MAJOR.MINOR.PATCH</code>：</p>
<ol>
<li><code>MAJOR</code>：进行不兼容的 API 更改时进行修改</li>
<li><code>MINOR</code>：向后兼容的方式添加新功能时进行修改</li>
<li><code>PATCH</code>：进行向后兼容的错误修复时进行修改</li>
</ol>
<p>先行版本号以及版本编译信息可以添加到 <code>MAJOR.MINOR.PATCH</code> 后面以作为延伸。</p>
<h2 id="CocoaPods-原理浅析"><a href="#CocoaPods-原理浅析" class="headerlink" title="CocoaPods 原理浅析"></a>CocoaPods 原理浅析</h2><h3 id="CococaPods-核心组件"><a href="#CococaPods-核心组件" class="headerlink" title="CococaPods 核心组件"></a>CococaPods 核心组件</h3><p>CocoaPods 被 Ruby 管理，其核心部分也被分为一个一个组件。下载源码，可以看到 Gemfile 文件如下，其依赖了若干个 gem，有意思的是 <code>cp_gem</code> 函数，通过 <code>SKIP_UNRELEASED_VERSIONS</code> 与 <code>path</code> 来控制是否采用本地的 gem 路径，实现了 DEVELOPMENT 与 RELEASE 环境的切换。</p>
<pre><code class="ruby">SKIP_UNRELEASED_VERSIONS = false

# Declares a dependency to the git repo of CocoaPods gem. This declaration is
# compatible with the local git repos feature of Bundler.
def cp_gem(name, repo_name, branch = 'master', path: false)
  return gem name if SKIP_UNRELEASED_VERSIONS
  opts = if path
           { :path =&gt; "../#{repo_name}" }
         else
           url = "https://github.com/CocoaPods/#{repo_name}.git"
           { :git =&gt; url, :branch =&gt; branch }
         end
  gem name, opts
end

source 'https://rubygems.org'

gemspec

group :development do
  cp_gem 'claide',                'CLAide'
  cp_gem 'cocoapods-core',        'Core'
  cp_gem 'cocoapods-deintegrate', 'cocoapods-deintegrate'
  cp_gem 'cocoapods-downloader',  'cocoapods-downloader'
  cp_gem 'cocoapods-plugins',     'cocoapods-plugins'
  cp_gem 'cocoapods-search',      'cocoapods-search'
  cp_gem 'cocoapods-trunk',       'cocoapods-trunk'
  cp_gem 'cocoapods-try',         'cocoapods-try'
  cp_gem 'molinillo',             'Molinillo'
  cp_gem 'nanaimo',               'Nanaimo'
  cp_gem 'xcodeproj',             'Xcodeproj'

  gem 'cocoapods-dependencies', '~&gt; 1.0.beta.1'
  ...
end
</code></pre>
<p>这些组件相对独立，被分成一个一个 Gem 包，在 <a target="_blank" rel="noopener" href="https://guides.cocoapods.org/contributing/components.html">Core Components</a> 中，可以找到对这些组件的简要描述。同时也可以到 CocoaPods 的 Github 中去看详细文档。</p>
<img src="https://raw.githubusercontent.com/xuhaodong1/resource/master/image-20221216104815073.png" style="zoom:40%;">

<ul>
<li><strong>CocoaPods</strong>：命令行支持与安装程序，也会处理 CocoaPods 的所有用户交互。</li>
<li><strong>cocoapods-core</strong>：对模版文件的解析，如 Podfile、.podspec 等文件。</li>
<li><strong>CLAide</strong>：一个简单的命令解析器，它提供了一个快速创建功能齐全的命令行界面的 API。</li>
<li><strong>cocoapods-downloader</strong>：用于下载源码，为各种类型的源代码控制器(HTTP/SVN/Git/Mercurial) 提供下载器。它提供 tags、commites、revisions、branches 以及 zips 文件的下载与解压缩操作。</li>
<li><strong>Monlinillo：CocoaPods</strong>：对于依赖仲裁算法的封装，它是一个具有前项检察的回溯算法。不仅在 pods 中，Bundler 和 RubyGems 也是使用这一套仲裁算法。</li>
<li><strong>Xcodeproj</strong>：通过 Ruby 来对 Xcode projects 进行创建于修改。如：脚本管理、libraries 构建、Xcode workspece 和配置文件的管理。</li>
<li><strong>cocoapods-plugins</strong>：插件管理，其中有 pod plugins 命令帮助你获取的可用插件列表以及开发一个新插件等功能，具体可用 <code>pod plugins --help</code> 了解。</li>
</ul>
<h3 id="pod-install-做了什么"><a href="#pod-install-做了什么" class="headerlink" title="pod install 做了什么"></a>pod install 做了什么</h3><p>执行 <code>pod install --verbose</code>，会显示 pod install 过程中的更多 debugging 信息。下文主要参考：<a target="_blank" rel="noopener" href="https://www.desgard.com/2020/08/17/cocoapods-story-2.html">整体把握 CocoaPods 核心组件</a></p>
<p>经过消息转发与 CLAide 命令解析，最终调用了 CocoaPods/lib/cocoapods/installer.rb 的 install! 函数，主要流程图如下：</p>
<img src="https://raw.githubusercontent.com/xuhaodong1/resource/master/image-20221216145652667.png" style="zoom:45%;">

<pre><code class="ruby">def install!
    prepare
    resolve_dependencies
    download_dependencies
    validate_targets
    clean_sandbox
    if installation_options.skip_pods_project_generation?
        show_skip_pods_project_generation_message
        run_podfile_post_install_hooks
    else
    integrate
    end
    write_lockfiles
    perform_post_install_actions
end
</code></pre>
<h4 id="1-Install-环境准备（prepare）"><a href="#1-Install-环境准备（prepare）" class="headerlink" title="1. Install 环境准备（prepare）"></a>1. Install 环境准备（prepare）</h4><pre><code class="ruby">def prepare
  # 如果检测出当前目录是 Pods，直接 raise 终止
  if Dir.pwd.start_with?(sandbox.root.to_path)
    message = 'Command should be run from a directory outside Pods directory.'
    message &lt;&lt; "\n\n\tCurrent directory is #{UI.path(Pathname.pwd)}\n"
    raise Informative, message
  end
  UI.message 'Preparing' do
    # 如果 lock 文件的 CocoaPods 主版本和当前版本不同，将以新版本的配置对 xcodeproj 工程文件进行更新
    deintegrate_if_different_major_version
    # 对 sandbox(Pods) 目录建立子目录结构
    sandbox.prepare
    # 检测 PluginManager 是否有 pre-install 的 plugin
    ensure_plugins_are_installed!
    # 执行插件中 pre-install 的所有 hooks 方法
    run_plugins_pre_install_hooks
  end
end
</code></pre>
<p>在 prepare 阶段会完成 <code>pod install</code> 的环境准备，包括目录结构、版本一致性以及 <code>pre_install</code> 的 hook。</p>
<h4 id="2-解决依赖冲突（resolve-dependencies）"><a href="#2-解决依赖冲突（resolve-dependencies）" class="headerlink" title="2. 解决依赖冲突（resolve dependencies）"></a>2. 解决依赖冲突（resolve dependencies）</h4><pre><code class="ruby">def resolve_dependencies
    # 获取 Sources
    plugin_sources = run_source_provider_hooks
    # 创建一个 Analyzer
    analyzer = create_analyzer(plugin_sources)
    # 如果带有 repo_update 标记
    UI.section 'Updating local specs repositories' do
        # 执行 Analyzer 的更新 Repo 操作
        analyzer.update_repositories
    end if repo_update?
    UI.section 'Analyzing dependencies' do
        # 从 analyzer 取出最新的分析结果，@analysis_result，@aggregate_targets，@pod_targets
        analyze(analyzer)
        # 拼写错误降级识别，白名单过滤
        validate_build_configurations
    end
    # 如果 deployment? 为 true，会验证 podfile &amp; lockfile 是否需要更新
    UI.section 'Verifying no changes' do
        verify_no_podfile_changes!
        verify_no_lockfile_changes!
    end if deployment?
    analyzer
end
</code></pre>
<p>通过 Podfile、Podfile.lock 以及 manifest.lock 等生成 Analyzer 对象，其内部会使用个 Molinillo 算法解析得到一张依赖关系表，进行一系列的分析与依赖冲突解决。</p>
<h4 id="3-下载依赖文件（download-dependencies）"><a href="#3-下载依赖文件（download-dependencies）" class="headerlink" title="3. 下载依赖文件（download dependencies）"></a>3. 下载依赖文件（download dependencies）</h4><pre><code class="ruby">def download_dependencies
  UI.section 'Downloading dependencies' do
    # 构造 Pod Source Installer
    install_pod_sources
    # 执行 podfile 定义的 pre install 的 hooks
    run_podfile_pre_install_hooks
    # 根据配置清理 pod sources 信息，主要是清理无用 platform 相关内容
    clean_pod_sources
  end
end
</code></pre>
<p>​    经过前面分析与解决依赖冲突后，这是会进行依赖下载。会根据依赖信息是否被新添加或者修改等信息进行下载，同时下载后也会在本地留有一份缓存，其目录在 ～/Library/Caches/CocoaPods 。</p>
<h4 id="4-验证-targets（validate-targets）"><a href="#4-验证-targets（validate-targets）" class="headerlink" title="4. 验证 targets（validate targets）"></a>4. 验证 targets（validate targets）</h4><pre><code class="ruby">def validate_targets
    validator = Xcode::TargetValidator.new(aggregate_targets, pod_targets, installation_options)
    validator.validate!
end

def validate!
    verify_no_duplicate_framework_and_library_names
    verify_no_static_framework_transitive_dependencies
    verify_swift_pods_swift_version
    verify_swift_pods_have_module_dependencies
    verify_no_multiple_project_names if installation_options.generate_multiple_pod_projects?
end
</code></pre>
<p><strong>verify_no_duplicate_framework_and_library_names</strong>：验证是否有重名的 framework / library</p>
<p><strong>verify_no_static_framework_transitive_dependencies</strong>：验证动态库是否有静态链接库依赖。个人认为，这个验证是不必要的，起码不必要 error。</p>
<p><strong>verify_swift_pods_swift_version</strong>：验证 Swift pod 的 Swift 版本配置且相互兼容</p>
<p><strong>verify_swift_pods_have_module_dependencies</strong>：验证 Swift pod 是否支持 module</p>
<p><strong>verify_no_multiple_project_names</strong>：验证没有重名的 project 名称</p>
<h4 id="5-生成工程（Integrate）"><a href="#5-生成工程（Integrate）" class="headerlink" title="5. 生成工程（Integrate）"></a>5. 生成工程（Integrate）</h4><pre><code class="ruby">def integrate
    generate_pods_project
    if installation_options.integrate_targets?
        # 集成用户配置，读取依赖项，使用 xcconfig 来配置
        integrate_user_project
    else
        UI.section 'Skipping User Project Integration'
    end
end

def generate_pods_project
    # 创建 stage sanbox 用于保存安装前的沙盒状态，以支持增量编译的对比
    stage_sandbox(sandbox, pod_targets)
    # 检查是否支持增量编译，如果支持将返回 cache result
    cache_analysis_result = analyze_project_cache
    # 需要重新生成的 target
    pod_targets_to_generate = cache_analysis_result.pod_targets_to_generate
    # 需要重新生成的 aggregate target
    aggregate_targets_to_generate = cache_analysis_result.aggregate_targets_to_generate

    # 清理需要重新生成 target 的 header 和 pod folders
    clean_sandbox(pod_targets_to_generate)
    # 生成 Pod Project，组装 sandbox 中所有 Pod 的 path、build setting、源文件引用、静态库文件、资源文件等
    create_and_save_projects(pod_targets_to_generate, aggregate_targets_to_generate,
                                cache_analysis_result.build_configurations, cache_analysis_result.project_object_version)

    # SandboxDirCleaner 用于清理增量 pod 安装中的无用 headers、target support files 目录
    SandboxDirCleaner.new(sandbox, pod_targets, aggregate_targets).clean!
    # 更新安装后的 cache 结果到目录 `Pods/.project_cache` 下
    update_project_cache(cache_analysis_result, target_installation_results)
end
</code></pre>
<p>将之前版本仲裁的所有组件通过 project 文件的形式组织起来，并对 project 中做一些用户指定的配置。</p>
<h4 id="6-写入依赖（write-lockfiles）"><a href="#6-写入依赖（write-lockfiles）" class="headerlink" title="6. 写入依赖（write lockfiles）"></a>6. 写入依赖（write lockfiles）</h4><pre><code class="ruby">def write_lockfiles
  @lockfile = generate_lockfile
  UI.message "- Writing Lockfile in #{UI.path config.lockfile_path}" do
    # No need to invoke Sandbox#update_changed_file here since this logic already handles checking if the
    # contents of the file are the same.
    @lockfile.write_to_disk(config.lockfile_path)
  end
  UI.message "- Writing Manifest in #{UI.path sandbox.manifest_path}" do
    # No need to invoke Sandbox#update_changed_file here since this logic already handles checking if the
    # contents of the file are the same.
    @lockfile.write_to_disk(sandbox.manifest_path)
  end
end
</code></pre>
<p>将依赖更新写入 Podfile.lock 与 Manifest.lock</p>
<h4 id="7-结束回调（perform-post-install-action）"><a href="#7-结束回调（perform-post-install-action）" class="headerlink" title="7. 结束回调（perform post install action）"></a>7. 结束回调（perform post install action）</h4><pre><code class="ruby">def perform_post_install_actions
  # 调用 HooksManager 执行每个插件的 post_install 方法 
  run_plugins_post_install_hooks
  # 打印过期 pod target 警告
  warn_for_deprecations
  # 如果 pod 配置了 script phases 脚本，会主动输出一条提示消息
  warn_for_installed_script_phases
  # 警告移除的 master specs repo 的 specs
  warn_for_removing_git_master_specs_repo
  # 输出结束信息 `Pod installation complete!`
  print_post_install_message
end
</code></pre>
<p>最后的收尾工作，进行 <code>post install action</code> 的 hook 执行以及一些 warning 打印。</p>
<h2 id="CocoaPods-Plugins"><a href="#CocoaPods-Plugins" class="headerlink" title="CocoaPods + Plugins"></a>CocoaPods + Plugins</h2><p>早在 2013 年，CocoaPods 就添加了对插件的支持，以添加不符合依赖管理和生态系统增长为主要目标的功能。CocoaPods Plugins 可以：在 install 前后添加 hook、添加新命令到 pod、以及利用 Ruby 动态性做任何事。下面介绍一下常见的插件：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/leavez/cocoapods-binary">cocoapods-binary</a>：一个比较早期的二进制插件库，是诸多二进制方案的灵感来源</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/wordpress-mobile/cocoapods-repo-update">cocoapods-repo-update</a>：自动化 pod repo update</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/upgrad/cocoapods-integrate-flutter">cocoapods-integrate-flutter</a>：将 flutter 与现有 iOS 应用程序集成</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/cocoapods-uploader">cocoapods-uploader</a>：上传文件/目录到远程仓库</p>
</li>
</ul>
<p>ps：许多插件可能许久未维护，读者使用需自行斟酌。</p>
<h2 id="不太常见概念"><a href="#不太常见概念" class="headerlink" title="不太常见概念"></a>不太常见概念</h2><p>CocoaPods 的配置内容几乎包含了 Xcode Build 的方方面面，因此存在许多不太常见的概念，在此做一个链接聚合以供参考。</p>
<ul>
<li>Clang Module / module_map / umbrella header：Clang Module 是 Clang 16.0.0 中引入的概念，用以解决 #include / #import 头文件引入导致的相关问题；module_map 是用以描述 clang module 与 header 的关系；umbrella header 则是 module_map 中的语法规范，表示指定目录中的头文件都应包含在模块中。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/Modules.html#introduction">Modules</a></p>
<p><a target="_blank" rel="noopener" href="http://chuquan.me/2021/02/11/clang-module/">Clang Module</a></p>
<p><a target="_blank" rel="noopener" href="https://www.stephenw.cc/2017/08/23/llvm-modules/">LLVM 中的 Module</a></p>
<ul>
<li>Hmap / Xcode Header / CocoaPods Headers</li>
</ul>
<p>Header Map 是一组头文件信息映射表，用 .hmap 后缀表示，整体结构以 Key-Value 形式存储；Key为头文件名称、Value 为 头文件物理地址。</p>
<p>Xcode Phases - Header 在构建配置中分为 public、private 与 project ，用以与 target 关联；其中 public 、private 就复制到最终产物的 header 和 PrivateHeaders 中，而 project 头文件不对外使用，则不会放到最终产物。</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2021/02/25/cocoapods-hmap-prebuilt.html">一款可以让大型iOS工程编译速度提升50%的工具</a></p>
<p><a target="_blank" rel="noopener" href="https://help.apple.com/xcode/mac/current/#/dev50bab713d">What are build phases?</a></p>
<ul>
<li>Xcconfig：</li>
</ul>
<p>一种配置文件，用以对构建设置进行声明与管理，比如区分不同的开发环境等。</p>
<p><a target="_blank" rel="noopener" href="https://nshipster.com/xcconfig/">Xcode Build Configuration Files</a></p>
<ul>
<li>On demand resource：WWDC 2015 引入的概念，对资源文件的按需加载。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2015/214/">Introducing On Demand Resources</a></p>
<h2 id="🔗："><a href="#🔗：" class="headerlink" title="🔗："></a>🔗：</h2><p>[1] <a target="_blank" rel="noopener" href="https://cocoapods.org/">Cocoapods.org</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://medium.com/orion-innovation-turkey/xcode-workspace-with-multiple-projects-1b42f5182c45">Xcode Workspace with multiple projects</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://objccn.io/issue-6-4/">深入理解 CocoaPods</a></p>
<p>[4] <a target="_blank" rel="noopener" href="http://chuquan.me/2021/02/14/understand-ios-library-and-framework/">系统理解 iOS 库与框架</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://swiftunwrap.com/article/cocoapods-script-phases/">Cocoapods script phases</a></p>
<p>[6] <a target="_blank" rel="noopener" href="http://chuquan.me/2021/12/24/podfile-analyze-principle/">CocoaPods Podfile 解析原理</a></p>
<p>[7] <a target="_blank" rel="noopener" href="https://semver.org/">Semantic Versioning 2.0.0</a></p>
<p>[8] <a target="_blank" rel="noopener" href="https://tech.meituan.com/2021/02/25/cocoapods-hmap-prebuilt.html">一款可以让大型iOS工程编译速度提升50%的工具</a></p>
<p>[9] <a target="_blank" rel="noopener" href="http://chuquan.me/2022/01/07/source-analyze-principle/#more">CocoaPods Source 管理机制</a></p>
<p>[10] <a target="_blank" rel="noopener" href="https://www.desgard.com/2020/06/11/cocoapods-story-1.html#podfilelock">版本管理工具及 Ruby 工具链环境</a></p>
<p>[11] <a target="_blank" rel="noopener" href="https://www.desgard.com/2020/08/17/cocoapods-story-2.html">整体把握 CocoaPods 核心组件</a></p>
<p>[12] <a target="_blank" rel="noopener" href="https://binlogo.github.io/post/gong-cheng-xiao-lu-you-hua-cocoapods-you-hua/">工程效率优化：CocoaPods优化</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/12/24/2022-12-24-nihao%E7%9A%842022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="nihao' 2022年终总结"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: nihao' 2022年终总结</span></a><a class="button is-default" href="/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" title="iOS中的事件以及事件传递机制"><span class="has-text-weight-semibold">Next: iOS中的事件以及事件传递机制</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xuhaodong1/xuhaodong1.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xuhaodong1"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p> <span>PV:</span><span id="busuanzi_value_site_pv"></span><span>  UV: </span><span id="busuanzi_value_site_uv"></span></p><p><span>Copyright ©</span><span> nihao 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>