<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS中的事件以及事件传递机制</title>
      <link href="/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 中有 8 种事件，本文重点介绍触摸事件的传递机制与响应流程。可以带着一下问题进行阅读：</p><ul><li>iOS 中有哪些事件类型，谁来进行事件的响应，怎么来响应呢？</li><li>触摸事件的传递与响应流程</li><li><code>hitTest</code> 方法的作用，它有什么实践场景？</li><li><code>UIControl</code> 与 <code>UIGestureRecognizer</code> 也能响应触摸事件，<code>UIResponder</code> 的响应方式有什么不同？<span id="more"></span></li></ul><h2 id="响应者-amp-响应者链"><a href="#响应者-amp-响应者链" class="headerlink" title="响应者 &amp; 响应者链"></a>响应者 &amp; 响应者链</h2><ul><li>响应者即 <code>UIResponder class</code> 的一个实例；</li><li>响应者链为响应者组成的一个链式结构，不同的链式结构组合起来看起来像一个倒过来的树形结构。</li><li><code>UIResponder</code> 中包含了许多处理事件的方法，如果我们想在这个对象里响应事件，那么重写这个方法即可。</li></ul><img src="/images/blog/responderChain.png" alt="A flow diagram: On the left, a sample app contains a label (UILabel), a text field for the user to input text (UITextField), and a button (UIButton) to  press after entering text in the field. On the right, the flow diagram shows how, after the user pressed the button, the event moves through the responder chain—from UIView, to UIViewController, to UIWindow, UIApplication, and finally to UIApplicationDelegate." style="zoom:67%;"><ul><li><strong>UIView</strong>：如果 <code>view</code> 是 <code>UIViewController</code> 的 <code>root view</code>，下一个响应者为 <code>UIViewController</code>，否则下一个响应者为<code>superview</code>。</li><li><strong>UIViewController</strong>：如果 <code>UIViewController</code> 的 <code>view</code> 是 <code>UIWindow</code> 的 <code>root view</code> 下一个响应者对象是 <code>window</code>；如果 当前 <code>UIViewController</code> 由另一个 <code>UIViewController push</code> 或者 <code>presented</code>，则下一个响应者为 弹出该 <code>vc</code> 的 <code>UIViewController</code>，例如 <code>UINavigationController</code>、<code>UITableBarController</code>。</li><li><strong>UIWindow</strong>：下一个响应者为 <code>UIApplication</code></li><li><strong>UIApplication</strong>：下一个响应者为 <code>UIApplicationDelegate</code>，前提是它不是 <code>UIView</code>、<code>UIViewController</code>、以及不是 <code>UIApplication</code> 本身。一般来说，是指 <code>AppDelegate</code>。</li></ul><h2 id="事件-amp-谁是事件的第一响应者"><a href="#事件-amp-谁是事件的第一响应者" class="headerlink" title="事件 &amp; 谁是事件的第一响应者"></a>事件 &amp; 谁是事件的第一响应者</h2><table><thead><tr><th>事件类型</th><th>第一响应者</th></tr></thead><tbody><tr><td>触摸事件 touch events</td><td>发生触摸的视图</td></tr><tr><td>按压事件 press events</td><td>被聚焦的对象</td></tr><tr><td>摇动事件 shake-motion events</td><td>你(or UIKit)指定的对象</td></tr><tr><td>远程控制事件 remote-control event</td><td>你(or UIKit)指定的对象</td></tr><tr><td>编辑菜单消息 editing menu messages</td><td>你(or UIKit)指定的对象</td></tr><tr><td>加速器 accelerometers</td><td>委任的对象</td></tr><tr><td>陀螺 gyroscopes</td><td>委任的对象</td></tr><tr><td>磁力仪 magnetometer</td><td>委任的对象</td></tr></tbody></table><p>在 iOS 中，有 8 种类型的事件，响应这些事件的对象被称为响应者，系统的一些常见的响应者为 <code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>、<code>UIAppllication</code>、<code>AppDelegate</code>，在找到最佳响应者后，如果事件没有被处理，事件会随着响应者链进行传递。不过有些事件在进行传递的时候，即使重写了响应事件的方法，特定对象不会进行响应，例如 <code>shake-motion events</code> 不会由 <code>UIView</code>、<code>UIApplication</code>、<code>AppDelegate</code> 进行响应。</p><ul><li>触摸事件 <code>touch events</code>，是 iOS 中最常见的事件，每一次触碰都会由 IOKit 通过 IPC 交给 SpringBoard，进而通过 <code>mach port</code> 传递给合适的进程进行响应，第一响应者是发生触碰的视图，后面会重点讲解。</li></ul><pre><code class="swift">open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)@available(iOS 9.1, *)open func touchesEstimatedPropertiesUpdated(_ touches: Set&lt;UITouch&gt;)</code></pre><ul><li>按压事件<code>press events</code>，表示如遥控器或者游戏手柄中进行按压触碰而产生的事件，由当前聚焦的对象进行响应。</li></ul><pre><code class="swift">@available(iOS 9.0, *)open func pressesBegan(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)@available(iOS 9.0, *)open func pressesChanged(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)@available(iOS 9.0, *)open func pressesEnded(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)@available(iOS 9.0, *)open func pressesCancelled(_ presses: Set&lt;UIPress&gt;, with event: UIPressesEvent?)</code></pre><ul><li>摇动事件 <code>shake-motion events</code>，晃动设备进行触发。</li></ul><pre><code class="swift">open func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?)open func motionEnded(_ motion: UIEvent.EventSubtype, with event: UIEvent?) open func motionCancelled(_ motion: UIEvent.EventSubtype, with event: UIEvent?)</code></pre><ul><li>远程控制事件 <code>remote-control event</code>，在音视频播放时，锁屏界面或者控制中心中点击 “上一个”、“下一个”、“暂停”和“继续”等操作时触发的事件。</li></ul><pre><code class="swift">@available(iOS 4.0, *)open func remoteControlReceived(with event: UIEvent?)</code></pre><ul><li>编辑菜单消息 <code>editing menu messages</code>，编辑文本出现的菜单列表产生的事件。</li></ul><pre><code class="swift">open func buildMenu(with builder: UIMenuBuilder)@available(iOS 13.0, *)open func validate(_ command: UICommand)@available(iOS 3.0, *)open var undoManager: UndoManager? { get }@available(iOS 13.0, *)open var editingInteractionConfiguration: UIEditingInteractionConfiguration { get }</code></pre><ul><li>加速器事件、陀螺事件、磁力仪事件不跟随响应者链，<code>Core Motion</code> 将这些事件直接传递给指定的委任对象。</li></ul><h2 id="触摸事件流程"><a href="#触摸事件流程" class="headerlink" title="触摸事件流程"></a>触摸事件流程</h2><img src="/images/blog/image-20220620215940554.png" alt="image-20220620215940554" style="zoom:80%;"><p>当触摸事件发生时，被用户面板即硬件由电信号采集到，之后再传递给 <code>IOKit.framework</code>，并将事件封装为 <code>IOHIDEvent</code>；之后通过 IPC 转发给 <code>SpringBoard</code> 进程；再由 <code>SpringBoard</code> 进程再次通过 <code>IPC</code> 将事件传递给合适的 APP 进程；由主线程 <code>RunLoop</code> 进行处理，先触发 <code>source1</code> 回调，后触发了 <code>source0</code> 回调，并将事件封装为 <code>UIEvent</code>；然后将事件加入 <code>UIApplication</code> 对象的事件队列中，出队后，开始寻找最佳响应者 <code>hit-Testing</code>，找到最佳响应者后。由 <code>UIApplication</code> 对象 从 <code>sendEvent</code> 方法将事件传递给 <code>window</code> 对象，再由 <code>window</code> 对象 <code>sendEvent</code> 到最佳响应者，随后进行事件响应以及传递。寻找最佳响应者以及事件响应后面会重点提及，这里先简单对 IOKit.framework、SpringBoard 以及 IPC 进行简单介绍：</p><ul><li>IOKit.framework：它为设备驱动程序(IOKit)的用户态组件，IOKit 来源于 NeXTSTEP 的 DriverKit，IOKit.framework 提供了内核态以及用户态双向通信的接口。</li><li>SpringBoard：iOS 中的 SpringBoard 相当于 macOS 中的 Finder，它向用户提供了熟悉的图标界面，它记录了多触摸事件、加速器事件、按压事件等。</li><li>IPC：macOS 和 iOS 中的进程间通信(InterProcess Communication) 是基于 mach，mach 是 iOS 和 macOS 中的核心，也是有别于其他操作系统的重点，mach 采用微内核的概念，即内核仅提供一些必要的功能，其他工作由用户态实现。mach 的 IPC 是通过在两个端口之间发送消息实现，具体可以参考 《深入解析Mac OS X &amp; iOS 操作系统》。</li></ul><h3 id="寻找最佳响应者"><a href="#寻找最佳响应者" class="headerlink" title="寻找最佳响应者"></a>寻找最佳响应者</h3><ol><li>由 <code>UIApplication</code> 传递给 <code>UIWindow</code>，如果有多个 <code>UIWindow</code> 对象，则按倒序进行查询。</li><li>对于每一个 <code>UIWindow</code>、<code>UIView</code> 对象来说，也是倒叙查询其子视图和本视图能否响应。</li></ol><p>如果从遍历方式来看，是一个反过来的 <code>dfs</code>。倒叙是因为如果有视图重叠，在上方的是后加入的对象；具体来说都是通过 <code>UIView</code> 的 <code>hitTest</code> 方法进行判断是不是最佳响应者，如果存在则返回该 <code>UIView</code>，不存在则返回 <code>nil</code>。</p><ul><li><code>hitTest(_ point: CGPoint, with event: UIEvent?)</code> <strong>模拟代码</strong></li></ul><pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? {    guard self.isUserInteractionEnabled &amp;&amp; !self.isHidden &amp;&amp; self.alpha &gt; 0.01 else {        return nil    }    if self.point(inside: point, with: event) {        for subview in subviews.reversed() {            let convertedPoint = subview.convert(point, from: self)            let hitTestView = subview.hitTest(convertedPoint, with: event)            if let hitTestView = hitTestView {                return hitTestView            }        }      return self    }    return nil}</code></pre><ol><li><p>需要 <code>isUserInteractionEnabled</code> 为 <code>true</code>、<code>isHidden</code> 为 <code>fasle</code> 且透明度 &gt; 0.01</p></li><li><p>如果命中点在视图内，尝试倒序遍历子视图，查找是否有更合适的点，若有则返回子视图的 <code>hitTest()</code>，若无则返回本视图(<code>self</code>)。</p></li><li><p>如果命中点不在视图内，则返回 <code>nil</code>。</p></li></ol><ul><li><code>point(inside point: CGPoint, with event: UIEvent?)</code> <strong>模拟代码</strong></li></ul><pre><code class="swift">override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool {    return bounds.contains(point)}</code></pre><ol><li>判断当前 bounds 是否包含该点。</li></ol><h3 id="触摸事件的响应以及传递"><a href="#触摸事件的响应以及传递" class="headerlink" title="触摸事件的响应以及传递"></a>触摸事件的响应以及传递</h3><p>找到最佳响应者后，<code>UIApplication</code> 对象 <code>sendEvent</code> 到响应该视图的 <code>UIWindow</code>，再有 <code>UIWindow</code> 对象 <code>sendEvent</code> 到最佳响应者，这一点可以通过查看调用栈帧看出：</p><img src="/images/blog/image-20220704022615988.png" alt="image-20220704022615988" style="zoom:100%;"><p>传递给最佳响应者后，便可以进行事件的响应了，对于触摸事件来说，调用上述提到的 5 个方法即代表响应。事件的拦截是通过 <code>open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code> 实现的，传递方式与规则见上文中 <strong>响应者 &amp; 响应者链</strong>：</p><ul><li>不重写，默认将事件交给响应者链传递</li><li>重写不掉用 <code>super.touchesBegan(touches, with: event)</code>，事件由该响应者处理，不进行传递</li><li>重写并调用 <code>super.touchesBegan(touches, with: event)</code>，将事件交给响应者链传递</li></ul><p>采用 <code>touchesBegan</code> 等系列方法以响应算是比较底层的方式，为快速响应各种类型的触摸事件，Apple 提供了 <code>UIGestureRecognizer</code> 与 <code>UIControl</code> 这两种方式。</p><h4 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h4><p>UIGestureRecognizer 手势识别器是处理视图中的触摸和按压事件的最好方式，如果我们仅用触摸事件基本响应方式进行处理的话，难度较大且不现实。它是一个基类，Apple 提供了 8 种手势，同时也可以创建自定义手势。</p><ul><li><code>UITapGestureRecognizer</code>：轻点手势</li><li><code>UIPinchGestureRecognizer</code>：捏合手势</li><li><code>UIRotationGestureRecognizer</code>：旋转手势</li><li><code>UISwipeGestureRecognizer</code>：滑动手势</li><li><code>UIPanGestureRecognizer</code>：拖拽手势</li><li><code>UIScreenEdgePanGestureRecognizer</code>：屏幕边缘拖拽手势</li><li><code>UILongPressGestureRecognizer</code>：长按手势</li><li><code>UIHoverGestureRecognizer</code>：指针悬停（macOS &amp; iPadOS）</li></ul><p>手势识别器分为离散型和持续性两种：</p><p>离散型手势在识别到手势后只调用一次 <code>action</code> 方法，其变化过程为：</p><ul><li><p>识别成功：Possible —&gt; Recognized</p></li><li><p>识别失败：Possible —&gt; Failed</p></li></ul><p>持续性手势在满足最初始识别条件后，会在手势信息变化中多次调用 action 方法，其变化过程为：</p><ul><li><p>完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Ended</p></li><li><p>不完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Cancel</p></li></ul><p><strong>对于 UIResponder 的触摸响应优先级来说，UIGestureRecognizer 的响应优先级会更高一点</strong>；在 hit-Testing 过程中，就会判断当前 <code>view</code> 的手势识别器是否符合条件，符合条件的手势识别器对象会保存在 <code>UIEvent</code> 中，并在 <code>sendEvent</code> 时首先发送给它，如果手势识别器识别成功，则默认会取消剩余的触摸响应事件，表现为调用 <code>touchesCancelled</code> 方法。</p><p>三个重要的属性会改变上述过程：</p><ul><li><code>cancelsTouchesInView</code>：默认为 true，表示在识别手势成功后，是否取消剩余的触摸响应事件；</li><li><code>delaysTouchesBegan</code>：默认为 false，表示是否在识别手势失败后，才将触摸事件传递给 <code>hit-Tested view</code>；</li><li><code>delaysTouchesEnded</code>：默认为 true，表示是否在识别手势失败后，才将 <code>touchesEnded</code> 事件发送给 <code>hit-Tested view</code>；</li></ul><p>手势冲突</p><p>手势默认是互斥的，但可以利用 <code>UIGestureRecognizerDelegate</code> 进行手势优先级处理。</p><h4 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h4><p>UIControl 是响应特定动作或意图的视觉元素的控件基类，它是 <code>UIView</code> 的子类，因此它也是响应者对象；<code>UIButton</code>、<code>UISwitch</code>、<code>UISlider</code> 等都是它的子类，也可以自定义 <code>UIControl</code>。通过  <code>addTarget(_:action:for:)</code> 指定响应事件和对象和方法，如果 <code>target</code> 为 <code>nil</code>，则按照响应链传递该事件。</p><pre><code class="swift">open func beginTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Boolopen func continueTracking(_ touch: UITouch, with event: UIEvent?) -&gt; Boolopen func endTracking(_ touch: UITouch?, with event: UIEvent?) // touch is sometimes nil if cancelTracking calls through to this.open func cancelTracking(with event: UIEvent?) // event may be nil if cancelled for non-event reasons, e.g. removed from window</code></pre><p>与 <code>UIResponder</code> 类似，<code>UIControl</code> 有 4 种跟踪触摸事件的方法，分别与 <code>UIResponder</code> 的 <code>began</code>、<code>moved</code>、<code>ended</code>、<code>cancelled</code> 相对应。如果查看其调用栈，可以发现在 <code>UIResponder</code> 方法内部调用了 <code>UIControl</code> 的跟踪方法。</p><p><img src="/images/blog/image-20220707113956921.png" alt="image-20220707113956921"></p><p>如果在响应事件的方法打断点，查看调用栈帧，会发现 <code>UIControl</code> 会首先将事件通过 <code>sendAction:to:forEvent:</code> 发送给 <code>UIApplication</code>，再通过 <code>sendAction</code> 转发给发送的对象的对象。</p><p><img src="/images/blog/image-20220707114606464.png" alt="image-20220707114606464"></p><p>与 <code>UIGestureRecognizer</code> 相比，事件仍会优先传递到 <code>UIGestureRecognizer</code>，这一点可以重写 <code>UIGestureRecognizer</code> 的 4 个响应方法验证。</p><p>如果 <code>UIControl</code> 是其子视图，会判断其是否为系统默认控件，系统默认控件则优先响应 <code>UIControl</code> 的 <code>action</code> 方法，如果为自定义控件，则默认优先响应 <code>UIGestureRecognizer</code> 的 <code>action</code>。值得注意的是，如果将 <code>UIGestureRecognizer</code> 的 <code>cancelsTouchesInView</code> 改为<code> false</code>(默认为 <code>true</code>)，则发现 <code>UIGestureRecognizer</code> 也会进行响应，个人理解为 <code>cancelsTouchesInView</code> 改变了响应互斥的特性，因此本身也会响应。 </p><p>如果 <code>UIControl</code> 为父视图或平级视图，由于仍会优先将事件传递到 <code>UIGestureRecognizer</code>， 则可以根据其 <code>cancelsTouchesInView</code>、<code>delaysTouchesBegan</code>、<code>delaysTouchesEnded</code> 判断事件能否传递到 <code>UIControl</code>，这一点 <code>UIControl</code> 与 <code>UIResponder</code> 一致。</p><h3 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h3><h4 id="扩大响应区域"><a href="#扩大响应区域" class="headerlink" title="扩大响应区域"></a>扩大响应区域</h4><ol><li>重写本视图的 <code>func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool</code> </li></ol><pre><code class="swift">override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool {    // 将响应区域扩大 30    return self.bounds.inset(by: .init(top: -30, left: -30, bottom: -30, right: -30)).contains(point)}</code></pre><ol start="2"><li>重写父视图的 <code>func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView?</code></li></ol><pre><code class="swift">override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? {    // 将响应区域扩大 30    // subView 为应扩大响应区域的视图    if subView.frame.inset(by: .init(top: -30, left: -30, bottom: -30, right: -30)).contains(point) {        return subView    }    return super.hitTest(point, with: event)}</code></pre><h4 id="根据触摸实时修改-view-位置"><a href="#根据触摸实时修改-view-位置" class="headerlink" title="根据触摸实时修改 view 位置"></a>根据触摸实时修改 view 位置</h4><pre><code class="swift">override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {    let touch = touches.randomElement()    let prePoint = touch?.precisePreviousLocation(in: self)    let currPoint = touch?.location(in: self)    if let prePoint = prePoint, let currPoint = currPoint {        let offsetX = currPoint.x - prePoint.x        let offsetY = currPoint.y - prePoint.y        self.transform = self.transform.translatedBy(x: offsetX, y: offsetY)    }}</code></pre><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events">Using Responders and the Responder Chain to Handle Events</a></p><p><a href="https://www.jianshu.com/p/c294d1bd963d">iOS 触摸事件全家桶</a></p><p><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer?language=objc">Apple - UIGestureRecognizer</a></p><p><a href="http://southpeak.github.io/2015/12/13/cocoa-uikit-uicontrol/">UIKit: UIControl</a></p><p>《深入解析Mac OS X &amp; iOS 操作系统》</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 中的调试技巧</title>
      <link href="/2022/06/01/debugging_in_xcode/"/>
      <url>/2022/06/01/debugging_in_xcode/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Xcode 内置了许多工具能够帮助开发者进行高效快速的 Debug，例如 LLDB、 Instruments、Debug View Hierarchy、Debug Memory Graph 等。本文将介绍 LLDB 中实用的命令，以及如何利用 Instruments 解决内存相关的问题。</p><span id="more"></span><h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>LLDB 是 LLVM 中的调试器组件，支持调试 C、Objective-C、C++编写的程序，Swift 社区维护了一个版本，增加了对该语言的支持，LLDB 是 Xcode 的默认调试器。对于熟练使用 Xcode 的开发者来说，创建断点、使断点无效是一件再简单不过的事情，只需要的源代码的左侧行数点击即可。但是在 LLDB 还有许多提升开发效率的事，例如 frame、breakpoint、expression、image 等命令。</p><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p>expression 主要用于「在当前线程执行表达式，并显示其返回值」。其语法如下：</p><p><code>expression &lt;cmd-options&gt; -- &lt;expr&gt;</code></p><p>例如被大家所熟知的 <code>po</code>、<code>p</code> 都是关于 <code>expression</code> 的缩写形式</p><ul><li><p><code>po</code> 是 <code>expression -O --</code> 的缩写形式</p></li><li><p><code>p</code> 是 <code>expression --</code> 的缩写形式</p></li></ul><p>可以看到，主要有可选参数与表达式两部分；为了区分可选参数与表达式，采用 <code>--</code> 进行分割，下面列举常用的一些可选参数：</p><ul><li><code>-D</code>，设置最大递归深度解析层级</li><li><code>-O</code>，打印特定语言的对象的 <code>description</code> 方法</li><li><code>-T</code>，显示变量类型</li><li><code>-f</code>，以特定格式化类型进行输出</li><li><code>-i</code>，执行表达式时忽略断点触发</li></ul><p>更多的可选参数可以通过 <code>help expression</code> 进行查看</p><p>同时，<code>expression</code> 还可以可以定义变量，但需在变量名前面加入 <code>$</code> 标识符，例如</p><p>在 Swift 中：</p><p><code> expression var width: CGFloat = 20.0</code></p><p>在 OC 中：</p><p><code> expression NSArray *$array = @[@"one", @"two"];</code></p><h3 id="进程流程控制"><a href="#进程流程控制" class="headerlink" title="进程流程控制"></a>进程流程控制</h3><img src="/images/blog/image-20220420112717291.png" alt="image-20220420112717291" style="zoom:200%;"><p>当程序运行或暂停时，在控制台上方会出现上图这 4 个按钮，这 4 个按钮分别对应着「进程暂停与继续」、「执行当前行」、「调入执行函数」、「跳出执行函数」，分别对应着以下 4 个命令：</p><ol><li><code>process continue(continue)</code></li><li><code>thread step-over(next、n)</code></li><li><code>thread step in(step、s)</code></li><li><code>thread step out(fin)</code></li></ol><p>断点对于调试来说是很重要的东西，只需要在 Xcode 源文件左侧点击即可添加断点，同时也会出现在 Breakpoint navigator 中：</p><img src="/images/blog/image-20220511110055321.png" alt="image-20220511110055321" style="zoom:50%;"><p>同时还可以添加列断点，如果你的一行代码中有几个表达式，你可能希望只停留在某一个表达式中，那么列断点就很有用了，右键想要断点的表达式，点击 Create Column Breakpoint 即可创建列断点。</p><img src="/images/blog/image-20220512110941465.png" alt="image-20220512110941465" style="zoom:67%;"><p>在 Breakpoint navigator 中点击左下角的 + 号，可以发现创建有 6 大类型的断点，不过主要来说可以分为两种：</p><ul><li>异常、错误断点：捕获异常和错误，在将要发生 Crash 时，提前暂停并定位到有错误的代码中。</li><li>符号断点：即 Symbolic Breakpoint，可以通过方法名称创建断点，当执行到对应的方法时，便会暂停。</li></ul><img src="/images/blog/image-20220512111557861.png" alt="image-20220512111557861" style="zoom:67%;"><p>还可以使用 breakpoint 命令来进行对断点的管理，下面介绍一些常见的命令：</p><ul><li><p><code>breakpoint list</code> 显示断点列表</p></li><li><p><code>breakpoint enable / disable / del &lt;breakpointId&gt;</code> 通过 id 开启、关闭、删除断点( id 即是 breakpoint list 显示的 id )</p></li><li><p><code>breakpoint set &lt;cmd-options&gt;</code>，创建断点的方式有很多种，但最常见的是通过文件名与代码行数创建，或者是符号化进行创建：</p><ul><li><code>breakpoint set -f &lt;fileName&gt; -l &lt;lineNum&gt;</code> 通过文件名与代码行数创建</li><li><code>breakpoint set -n &lt;function_name&gt;</code> 通过方法名创建</li></ul></li></ul><p>同时还可以在 Breakpoint navigator 中对断点进行编辑，给断点创建名称、断点触发执行条件、暂停前忽略次数、执行 Action，以及执行完 Action 后继续执行。</p><img src="/images/blog/image-20220518170038329.png" alt="image-20220518170038329" style="zoom:67%;"><p>不过上述的功能都可以通过命令行实现，例如创建执行 Action 与 断点触发执行条件如下：</p><p><code>breakpoint set -C &lt;command&gt; -c &lt;condition expression&gt; -n &lt;function_name&gt;</code></p><p>更多功能可通过 <code>help breakpoint</code> 进行查看。</p><p>如果想观察某个值发生变化，那么 <code>watchpoint</code> 会非常有用，同样创建 <code>watchpoint</code> 有 2 种方式，在 debug 时右键属性并点击 <code>watch "&lt;variable-name&gt;"</code>。</p><img src="/images/blog/image-20220512153529644.png" alt="image-20220512153529644" style="zoom:67%;"><p>控制台则可以 <code>watchpoint set variable [-w &lt;watch-type&gt;] [-s &lt;byte-size&gt;] &lt;variable-name&gt;</code> 进行创建。</p><h2 id="其他常见的命令"><a href="#其他常见的命令" class="headerlink" title="其他常见的命令"></a>其他常见的命令</h2><p>frame 命令可以显示当前栈帧的一些信息：</p><ul><li><code>frame info</code>：显示栈帧所在位置</li><li><code>frame variable &lt;variableName&gt;</code>：显示栈帧变量，如果没有 <code>&lt;variableName&gt;</code> 则显示栈帧的变量列表，别名 v</li></ul><p>thread 用于操作当前进程的一个或多个线程</p><ul><li><p><code>thread list</code>：显示所有线程</p></li><li><p><code>thread info</code>：显示线程的额外概要</p></li><li><p><code>thread backtrace</code> ：显示线程的调用栈</p></li><li><p><code>thread continue</code>：继续执行一个或多个指定线程</p></li><li><p><code>thread exception</code>：显示线程异常对象</p></li><li><p><code>thread return</code>：提前返回一个栈帧，并可提供可选返回值</p></li></ul><p>process 在当前平台与进程交互</p><ul><li><code>process continue</code>：继续执行当前进程中的所有线程</li><li><code>process interrupt</code>：中断当前进程</li><li><code>process kill</code>：结束当前进程</li><li><code>process status</code>：显示当前进程状态</li></ul><p>image 可以访问目标模块的信息（是 <code>target modules</code> 的缩写）</p><ul><li><code>image list</code>：列出当前可执行和依赖的共享库镜像</li><li><code>image lookup</code>：根据参数查找其在可执行和依赖的共享库镜像的信息(如：地址、文件名、方法名、符号等)</li><li><code>image search-paths</code>：搜索路径的配置项</li><li><code>image show-unwind</code>：显示函数合成的 unwind 指令</li></ul><p>disassemble  显示当前 target 中的指定汇编指令，默认是当前线程和当前栈帧中的当前方法</p><ul><li><code>disassemble</code>：当前线程和当前栈帧中的当前方法的汇编指令</li><li><code>disassemble -a &lt;address-expression&gt;</code>：从某一地址开始</li><li><code>disassemble -n &lt;function-name&gt;</code>：从某一方法开始</li></ul><p>最后，还可以利用 commond alias 或者编写 python 脚本来实现自己的 LLDB 命令。</p><h2 id="po-amp-p-amp-v"><a href="#po-amp-p-amp-v" class="headerlink" title="po &amp; p &amp; v"></a>po &amp; p &amp; v</h2><p>po、p、v 都可以用来打印变量，那么它们有什么不同呢？</p><ul><li>po 显示对象的 <code>debugDescription</code> 属性，系统会提供默认值，可以通过实现 <code>CustomDebugStringConvertible</code> 协议进行自定义。</li></ul><p>po 后面跟表达式，因此可以执行方法，赋值等操作。po 的执行步骤分为两部分，第一步生成源代码，并在上下文中编译执行，第二步获取第一步返回的对象，并再次生成源代码并在上下文中编译执行，最后显示第二步返回的字符串。这里需要注意的是，为了能够使你的表达式能够被完整表达，LLDB 没有采取直接解析和评估表达式本身，采用生成可编译的源代码进行处理，这种方式完全保留了代码本身。例如，你输入 <code>po view</code>。</p><p>第一步生成的源代码为：</p><pre><code>func __lldb_expr() {     __lldb_res = view}</code></pre><p>第二步生成的源代码为：</p><pre><code>func __lldb_expr2() -&gt; String {    return __lldb_res.debugDescripution}</code></pre><img src="/images/blog/image-20220522170206675.png" alt="image-20220522170206675" style="zoom:67%;"><ul><li>p 命令，p 与 po 的输出略有不同，但都包含相同的信息，每个表达式结果都会被赋予增值名称，如 $R1、$R2等，这些结果就会被存储起来，并可以像普通的对象一样使用。p 命令执行分为 3 步，第一步与 po 命令相同，将表达式生成源代码，并进行编译执行，之后会进行动态类型解析，并将解析结果格式化。动态类型解析是由于其多态性，只有在运行时才能得知其运行时类型；对解析结果进行格式化是由于 Swift 标准库即使针对 Int、String 这样的简单类型，都进行了高度优化，因此其有复杂表达，所以需要进行格式化。</li></ul><img src="/images/blog/image-20220523174847611.png" alt="image-20220523174847611" style="zoom:35%;"><ul><li>v 命令，v 命令的输出与 p 完全一样。但与 p 和 po 不同的是，v 命令并不进行编译与执行代码，所以它非常快，它采用点和下标符来访问字段。v 命令执行分为 4 步，首先会查询进程状态为了内存中定位变量，之后便从内存中读取变量，并对其执行动态类型检查，如果它有访问子属性，则多次进行内存读取变量以及动态类型检查。最后将结果进行格式化。</li></ul><img src="/images/blog/image-20220523180303016.png" alt="image-20220523180303016" style="zoom:35%;"><h2 id="Debug-View-Hierarchy"><a href="#Debug-View-Hierarchy" class="headerlink" title="Debug View Hierarchy"></a>Debug View Hierarchy</h2><p>首先从 Xcode 中的 <code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics</code> 中开启 <code>Malloc Stack Logging</code> 选项，并选择 <code>All Allocation and Free History</code>。这开启了创建堆栈信息调用日志，在 Debug 时便可通过对象的信息去查看其调用堆栈。</p><p>打开 Debug View Hierarchy，便可发现在右侧的 Backtrace 中有了内容，如果你有约束冲突，或者想查看某个视图的创建信息，只需要在左侧的图层结构或者中间的图像选中你想要的即可。</p><p><img src="/images/blog/image-20220518192011839.png" alt="image-20220518192011839"></p><p>同样的 LLDB 还给我们带来了更加强大的功能，可以达到不需要重新编译从而改变视图的一些行为，具体实现方法可以类似如下：</p><ol><li>定位到某个具体的对象，即从界面中选中某一个视图或者约束。</li><li> 按钮 commond + c 便可复制其带有类型的内存地址，这时便可以对它进行操作，具体的在控制台中，输入你想要改变的操作，如：</li></ol><p>​    <code>e [((UIView *)0x7fa9320061a0) setBackgroundColor: [UIColor greenColor]]</code>  </p><p>注意这里需要使用 Objective-C 的语法，因为 Swift 的安全性导致不能访问所有内容。</p><ol start="3"><li>这时你发现界面没有改变，需要刷新视图：</li></ol><p><code>e (void) [CATransaction flush];</code></p><p>具体关于 Debug View Hierarchy 的更多用法可参考<a href="https://www.jianshu.com/p/9800c919e6cc">这里</a>。</p><h2 id="Debug-Memory-Graph"><a href="#Debug-Memory-Graph" class="headerlink" title="Debug Memory Graph"></a>Debug Memory Graph</h2><p>点开 Debug Memory Graph，会暂停进程，并显示当前堆的所有对象，并且会显示它们之间的所属关系和强引用与弱引用（深色的为强引用，浅色的为弱引用）。</p><p>如果你开启了 <code>Malloc Stack Logging</code>，也同样能看见对象的堆栈调用信息。</p><p>不仅如此，还可以发现内存泄漏，可以点开左下角的感叹号，仅筛选出内存泄漏对象。不过令人遗憾的是，Debug Memory Graph 并不能显示出所有的内存泄漏问题。例如下图，在 SecondViewController 持有 block 与 block 中去持有 SecondViewController 中的 view，这是经典的由 block 导致的循环引用，虽然 Debug Memory Graph 没有明确捕捉到，但是仍给我们排查提供了线索。</p><p><img src="/images/blog/image-20220519190816761.png" alt="image-20220519190816761"></p><p>点击 Edit -&gt; Export Memory Graph，可以导出内存分布图文件。利用 vmmap、leaks、heap 等命令行工具可以进一步分析内存问题，具体分析可参考 <a href="http://www.yuezyevil.com/2021/01/14/iOS%20%E5%86%85%E5%AD%98%E8%B0%83%E8%AF%95%E7%AF%87%20%E2%80%94%E2%80%94%20memgraph/">iOS 内存调试篇 – memgraph</a>。</p><h2 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h2><p>Instruments 提供了一套丰富工具和模版去分析 应用的性能问题，常见的模版有：</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>Leaks</td><td>一般的查看内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录。</td></tr><tr><td>Time Profiler</td><td>执行对系统的 CPU上运行的进程低负载时间为基础采样。</td></tr><tr><td>Allocations</td><td>跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史。</td></tr><tr><td>Activity Monitor</td><td>显示器处理的 CPU、内存和网络使用情况统计。</td></tr><tr><td>Blank</td><td>创建一个空的模板，可以从 Library 库中添加其他模板。</td></tr><tr><td>Core Data</td><td>监测读取、缓存未命中、保存等操作，能直观显示是否保存次数远超实际需要。</td></tr><tr><td>Network</td><td>跟踪 TCP/IP 和 UDP/IP 连接。</td></tr><tr><td>Engergy Log</td><td>应用的电量消耗情况。</td></tr></tbody></table><p> 下面基于 Time Profiler 模版，梳理如何使用 Instruments：</p><ol><li>首先选中 Time Profiler，会出现空的配置页</li><li>在左上方中选择分析的设备以及应用</li><li>点击开始，这时便可操作测试你的应用。</li><li>当操作完成，点击暂停或结束，这时便可针对有问题的数据进行分析。</li></ol><p><img src="/images/blog/image-20220531171357436.png" alt="image-20220531171357436"></p><p>选取你认为可疑的时间段，例如大量占用 CPU 的时间段，其次逐步根据去排查代码问题，例如主线程中有耗时操作。</p><p>更推荐看下 WWDC 中关于 Instruments 的介绍 <a href="https://developer.apple.com/videos/play/wwdc2019/411/">WWDC2019 - Get Started with Instruments</a>，笔者只是简单的概述。关于 Instruments，它没有记录所有的调用栈帧，而是在每秒去记录许多次栈帧快照，这是为了更好的性能体验。</p><h2 id="无限调试"><a href="#无限调试" class="headerlink" title="无限调试"></a>无限调试</h2><p>还有一个关于调试的小技巧，如果你希望不使用数据线连接电脑，可以采用局域网的形式连接，同样也可以进行真机运行与调试。具体在 Device 列表中右键设备并点击 Connect via IP Address。</p><img src="/images/blog/image-20220531144036056.png" alt="image-20220531144036056" style="zoom:67%;"><p>除此之外在菜单栏中选中 Debug 的 Attach to Process by Pid or Name 或者 Attach to Process … 通过列表选中想要附加的进程，就可以不用想要 Debug 的时候再次手动 Run 一次。不过这两种方式，都会有一定性能损耗，会导致响应时间慢问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了 LLDB 的一些常见命令，据统计，一名程序员大约有 70% 的时间都在 Debug，如果能够熟练使用它们，无疑会极大提升编程效率。同时还介绍了如 Debug View Hierarchy、Debug Memory Graph 的常见用法。特别是 Debug Memory Graph，因为内存问题往往是不易察觉且不易找到的，好好利用它，能够让我们对内存问题研究的更加深入。最后是 Instruments，它里面有许多工具，针对各方面的性能问题都有所涵盖，Jonathan Levin 称，与其他操作系统相比，Instruments 是最好的调试和性能剖析工具。</p><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p><a href="https://objccn.io/issue-19-2/">与调试器共舞 - LLDB 的华尔兹</a></p><p><a href="https://medium.com/@vin.pradeilles/advanced-debugging-with-xcode-5e6c8dabd311">用 LLDB 调试 Swift 代码</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2018/412/">WWDC2018 - 412 通过 Xcode 和 LLDB 进行高级调试</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/429/">WWDC2019 - 429 LLDB 不限于 “po”</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/411/">WWDC2019 - 411 Get Started with Instruments</a></p><p>《深入解析 Mac OS X &amp; iOS 操作系统》</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
            <tag> Instrument </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的多线程与线程安全</title>
      <link href="/2022/04/02/iOS%20%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/04/02/iOS%20%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <strong>iOS</strong> 中有 3 种线程管理安全，分别是 <strong>NSThread</strong>、<strong>GCD</strong> 与 <strong>NSOperation</strong>，不包含几乎不直接使用的 <strong>pthread</strong> 。本文就其使用特点以及重要的 <strong>API</strong> ，以及线程安全等方面进行总结。</p><span id="more"></span><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>轻量级线程操作，面向对象，但需手动管理线程声明周期，同时控制不同线程之间执行顺序不是很友好。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="swift">init(target: Any, selector: Selector, object argument: Any?) // 需要手动 start()init(block: @escaping () -&gt; Void) // 需要手动 start()detachNewThread(_ block: @escaping () -&gt; Void) // 自启动detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?) // 自启动performSelector(inBackground aSelector: Selector, with arg: Any?) // 隐式创建</code></pre><h3 id="线程状态控制"><a href="#线程状态控制" class="headerlink" title="线程状态控制"></a>线程状态控制</h3><pre><code class="swift">start() // 启动sleep(until date: Date) // 休眠到指定时间sleep(forTimeInterval ti: TimeInterval) // 休眠指定时间exit() // 强制立即退出，不管是否执行完毕，可能会导致异常cancel() // 不会立即退出，待到处理完线程上下文后退出，可用 isCancel 监听其是否退出</code></pre><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><pre><code class="swift">performSelector(onMainThread aSelector: Selector, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?) // 到主线程中执行performSelector(onMainThread aSelector: Selector, with arg: Any?, waitUntilDone wait: Bool) // 到主线程中执行perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?) // 到指定线程中执行perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool) // 到指定线程中执行</code></pre><h3 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h3><pre><code class="swift">let thread = CusThread.init(target: self, selector: #selector(threadAction), object: nil)@objc func threadAction() {    let runLoop = RunLoop.current    runLoop.add(.init(), forMode: .default)    while !Thread.current.isCancelled {        runLoop.run(mode: .default, before: Date.init(timeInterval: 2, since: .now)) // 两秒执行一次        otherAction()    }    }</code></pre><p><strong>runLoop</strong> 需添加 <strong>port</strong> / <strong>timer</strong> 等内容，否则 <strong>runLoop</strong> 会立即退出<br>在需退出时手动调用 <strong>cancel</strong>() 方法，防止 <strong>RunLoop</strong> 持有 <strong>Thread</strong> 导致内存泄露问题</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p><strong>Grand Central Dispatch（GCD）</strong> 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p></blockquote><p><strong>GCD</strong> 是 <strong>iOS</strong> 推出的多线程解决方案，其更强调「任务块」的概念，忽略了对线程的管理；<strong>GCD</strong> 是由 <strong>C</strong> 语言编写的轻量级线程处理方式，其源码在<a href="https://github.com/apple/swift-corelibs-libdispatch">这里</a>，在其内部维护了 <strong>pthread</strong> 生成的线程池的概念。</p><h3 id="任务-amp-队列"><a href="#任务-amp-队列" class="headerlink" title="任务 &amp; 队列"></a>任务 &amp; 队列</h3><p><strong>GCD</strong> 中的核心概念 「队列」 与 「任务」：</p><p>队列即执行任务的等待队列，以先进先出为原则执行队列中的任务，主要分为 <strong>串行队列</strong> 与 <strong>并行队列</strong></p><ul><li>串行队列（<strong>Serial Dispatch Queue</strong>）：每次只有一个任务执行。</li><li>并行队列（<strong>Concurrent Dispatch Queue</strong>）： 可以让多个任务并发执行。</li></ul><pre><code class="swift">let queue = DispatchQueue(label: "name") // 串行队列创建 / 默认let queue = DispatchQueue(label: "name", attributes: .concurrent) // 并行队列创建</code></pre><p>任务即你放入 <strong>GCD</strong> 中的代码块，分为同步和异步两种</p><ul><li>同步任务（<strong>sync</strong>）：同步任务会等待队列中前面的任务执行完再执行，在当前线程执行任务，不具备开启线程能力。</li><li>异步任务（<strong>async</strong>）：异步任务无需等待前面的任务执行完，即可继续执行任务，在新线程中执行任务，具备开启线程能力。</li></ul><pre><code class="swift">queue.sync { // 追加同步任务    print(Thread.current)} queue.async { // 追加异步任务    print(Thread.current)} </code></pre><p><strong>主队列</strong>：即主线程所在队列，是一个串行队列，可通过<code>DispatchQueue.main</code> 获取</p><p><strong>全局队列</strong>：并行队列，可通过<code>DispatchQueue.global()</code> 获取，同时还可根据任务优先级不同获取不同的全局队列：<code>DispatchQueue.global(qos: .background)</code></p><p>由于任务是追加到队列中，因此有 4 种组合方式：</p><table><thead><tr><th align="left"></th><th align="left">并发队列</th><th align="left">串行队列</th><th>主队列</th></tr></thead><tbody><tr><td align="left">同步（sync）</td><td align="left">没有开启新线程 / 串行执行任务</td><td align="left">没有开启新线程 / 串行执行任务</td><td>没有开启新线程 / 串行执行任务</td></tr><tr><td align="left">异步（async）</td><td align="left">开启新线程 / 并发执行任务</td><td align="left">开启新线程 / 串行执行任务</td><td>没有开启新线程 / 串行执行任务</td></tr></tbody></table><h3 id="GCD-中的死锁"><a href="#GCD-中的死锁" class="headerlink" title="GCD 中的死锁"></a>GCD 中的死锁</h3><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></blockquote><p>死锁有四个必要条件：互斥 &amp; 请求保持 &amp; 不可剥夺 &amp; 环路条件。</p><p>在 <strong>GCD</strong> 中，由于不当使用 <strong>API</strong> 则可能会造成死锁，这个死锁的概念不像上述表示那样，主要是任务间的相互等待导致无法执行任务造成，较为常见的如下：</p><p>在主线程中执行</p><pre><code class="swift">DispatchQueue.main.sync {    print(Thread.current) // 同步任务}// 当前任务</code></pre><pre><code class="swift">let queue = DispatchQueue.init(label: "name")    queue.sync {        queue.sync {              print(Thread.current) // 同步任务        }      } // 当前任务    print(Thread.current)  }</code></pre><p>原因：同步的任务无法开始，需等待当前队列中的任务执行完，而当前任务又因同步的任务导致无法完成。</p><h3 id="其他重要的API"><a href="#其他重要的API" class="headerlink" title="其他重要的API"></a>其他重要的<strong>API</strong></h3><h4 id="DiapatchGroup"><a href="#DiapatchGroup" class="headerlink" title="DiapatchGroup"></a>DiapatchGroup</h4><p>在追加多个异步任务后统一进行任务执行，可以采用 <strong>DispatchGroup</strong>，同样的基于手动将任务加入到 <strong>DispatchGroup</strong> 中(<strong>enter</strong> / <strong>leave</strong>)也可在多个网络请求后做同步操作。</p><pre><code class="swift">// 将任务加入到DispatchGrouplet group = DispatchGroup()let queue = DispatchQueue.init(label: "name", attributes: .concurrent)for i in 1...5 {    queue.async(group: group, execute: {      print("------ \(i)")    })}group.notify(queue: queue) {    print("end")}// 手动将任务加入到DispatchGrouplet group = DispatchGroup()let queue = DispatchQueue.init(label: "name", attributes: .concurrent)for i in 1...5 {    group.enter()    netwrk.api {        group.leave()    }}group.notify(queue: queue) {    print("end")}</code></pre><h4 id="栅栏函数-barrier"><a href="#栅栏函数-barrier" class="headerlink" title="栅栏函数(barrier)"></a>栅栏函数(barrier)</h4><p>栅栏任务会在前面任务都执行完后执行，在栅栏任务执行完后才会执行后面追加的任务，在具体场景中，可以用于“读者-写者问题”，即同一时刻可以有多个读者，但同一时刻只能有一个写者，如数据库的读写操作。</p><img src="/images/blog/image-20220328172310546.png" alt="image-20220328172310546" style="zoom: 67%;"><pre><code class="swift">queue.async(group: nil, qos: .default, flags: .barrier) {    print("隔离")}</code></pre><h4 id="延迟执行-asyncAfter"><a href="#延迟执行-asyncAfter" class="headerlink" title="延迟执行(asyncAfter)"></a>延迟执行(asyncAfter)</h4><p>延迟指定时间后将延迟任务加入到队列中，需要注意的是可以传递 <strong>DispatchTime</strong> 和 <strong>DispatchWallTime</strong> 这两个时间，前者是基于系统时间，不可被改变，后者为系统时钟，即锁屏界面的时间。</p><pre><code class="swift">queue.asyncAfter(deadline: .now() + 1) {    print("执行")}</code></pre><h4 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h4><p><strong>DispatchSemaphore</strong> 与 操作系统中的信号量一样，都是用来避免数据竞争这一类问题的，在 <strong>iOS</strong> 中常用来控制并发任务执行的最大数量。</p><ul><li>**singal()**：将 信号量 + 1</li><li>**wait()**：若此时信号量 &gt;= 1时，将信号量减 1，然后返回；若信号量 &lt;= 0时，则阻塞线程进行等待。</li></ul><pre><code class="swift">let semaphore = DispatchSemaphore(value: 3) // 将并发任务执行数量控制为3let queue = DispatchQueue.init(label: "name", attributes: .concurrent)for i in 1...5 {    semaphore.wait()    queue.async {        print(i)        semaphore.signal()    }}</code></pre><h4 id="调度源-DispatchSource"><a href="#调度源-DispatchSource" class="headerlink" title="调度源(DispatchSource)"></a>调度源(DispatchSource)</h4><p><strong>DispatchSource</strong> 用于监听系统的底层对象，比如文件描述符、<strong>Mach</strong> 端口、信号量、内存警告等。主要处理时间如下表：</p><table><thead><tr><th align="left">宏定义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DispatchSourceUserDataAdd</td><td align="left">数据增加</td></tr><tr><td align="left">DispatchSourceUserDataOr</td><td align="left">数据OR</td></tr><tr><td align="left">DispatchSourceMachSend</td><td align="left">Mach端口发送</td></tr><tr><td align="left">DispatchSourceMachReceive</td><td align="left">Mach端口接收</td></tr><tr><td align="left">DispatchSourceMemoryPressure</td><td align="left">内存情况</td></tr><tr><td align="left">DispatchSourceProcess</td><td align="left">进程事件</td></tr><tr><td align="left">DispatchSourceRead</td><td align="left">读数据</td></tr><tr><td align="left">DispatchSourceSignal</td><td align="left">信号</td></tr><tr><td align="left">DispatchSourceTimer</td><td align="left">定时器</td></tr><tr><td align="left">DispatchSourceFileSystemObject</td><td align="left">文件系统变化</td></tr><tr><td align="left">DispatchSourceWrite</td><td align="left">文件写入</td></tr></tbody></table><p>例如：</p><p><strong>监听内存情况</strong></p><pre><code class="swift">var source = DispatchSource.makeMemoryPressureSource(eventMask: .all, queue: .main)source.setEventHandler {    print(source.data)    // data为枚举值的rawValue, 主要有 normal、warning、critical、all}source.activate()</code></pre><p><strong>定时器</strong></p><pre><code class="swift">var source: DispatchSourceTimer?source = DispatchSource.makeTimerSource(flags: .strict, queue: .main)source?.schedule(deadline: .now() + 1, repeating: 1)source?.setEventHandler {    print("定时器触发\(Date.now)")}source?.activate()</code></pre><p>值得注意的是，在使用 <strong>NSTimer</strong> 时，若在滑动页面时，此 <strong>NSTimer</strong> 会失效，需给 <strong>timer</strong> 加入的 <strong>RunLoop</strong> 添加 <strong>commonMode</strong> 模式，若采用  <strong>DispatchSourceTimer</strong>，则不会出现这种情况。</p><p>需注意以上代码 <code>source</code> 不要以局部变量进行测试，否则超出作用域就被释放。</p><h4 id="DispatchIO"><a href="#DispatchIO" class="headerlink" title="DispatchIO"></a>DispatchIO</h4><p><strong>DispatchIO</strong> 提供一个操作文件描述符的通道，可以利用多线程高效的读取文件。以下是主要流程：</p><ol><li>创建 <strong>DispatchIO</strong> 对象，创建通道</li><li>进行 <strong>read</strong> / <strong>write</strong> 操作</li><li>调用 <strong>close</strong> 关闭通道</li><li>进行 <strong>cleanupHandler</strong> 回调处理</li></ol><pre><code class="swift">var ioWrite: DispatchIO?var ioRead: DispatchIO?let queue = DispatchQueue(label: "com.nihao.serialQueue")let filePath: NSString = (NSTemporaryDirectory() + "text.txt") as NSStringlet fileDescriptor = open(filePath.utf8String!, (O_RDWR | O_CREAT | O_APPEND), (S_IRWXU | S_IRWXG))let cleanupHandler: (Int32) -&gt; Void = { errorNumber in    print("最后的回调")}ioWrite = DispatchIO(type: .stream, fileDescriptor: fileDescriptor, queue: queue, cleanupHandler: cleanupHandler)ioRead = DispatchIO(type: .stream, fileDescriptor: fileDescriptor, queue: queue, cleanupHandler: cleanupHandler)let formattedString = "nihao!!!!!"let data = Array(formattedString.utf8).withUnsafeBytes {    DispatchData(bytes: $0)}ioWrite?.write(offset: 0, data: data, queue: queue) { done, data, error in }ioRead?.read(offset: 0, length: Int.max, queue: queue) { done, data, error in }</code></pre><h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p><strong>NSOperation</strong> 是基于 <strong>GCD</strong> 的面向对象的封装，因此也有「任务 <strong>NSOperation</strong>」和「队列 <strong>NSOperationQueue</strong>」两个概念，同时也增加了 <strong>NSOperation</strong> 之间相互依赖、通过 <strong>KVO</strong> 监听 <strong>NSOperation</strong> 状态、取消任务等特性。</p><p><strong>NSOperation</strong> 是一个形式上的抽象类，系统提供了 <strong>NSInvocationOperation</strong> 和 <strong>NSBlockInvocation</strong> 两个子类，但由于 <strong>NSInvocation</strong> 在 <strong>Swift</strong> 中不可使用，所以在 <strong>Swift</strong> 中 <strong>NSInvocationOperation</strong> 也不可用。同时也可以自定义 <strong>NSOperation</strong>，若仅使用 <strong>NSOperation</strong> 则任务只会在主线程运行，因此需和 <strong>NSOperationQueue</strong> 搭配使用。</p><p><strong>NSOperationQueue</strong> 初始化后就是一个并发队列，它会根据优先级与准备情况调用任务，可通过类属性 <code>main</code> 获取主队列，主要是通过给队列添加 <strong>operation</strong> 进行操作。值得注意的是，当任务已经被执行或执行已结束后就不能被再次添加进队列，否则会产生 <strong>crash</strong>。下面是一些使用范例：</p><pre><code class="swift">let queue = OperationQueue()queue.maxConcurrentOperationCount = 2 //设置最大并发数let operationA = BlockOperation { () -&gt; Void in    print("A - \(Thread.current)")}let operationB = BlockOperation { () -&gt; Void in    print("B - \(Thread.current)")}operationA.addDependency(operationB) // A 依赖于 B, 当 B 执行后 A 才会执行queue.addOperation(operationA)queue.addOperation(operationB)queue.addBarrierBlock {    print("我是屏障")}queue.addOperation { () -&gt; Void in    print("2 - \(Thread.current)")}</code></pre><h3 id="自定义-NSOperation"><a href="#自定义-NSOperation" class="headerlink" title="自定义 NSOperation"></a>自定义 NSOperation</h3><p>通常来说非并发 <strong>NSOperation</strong>，自定义 <strong>NSOperation</strong> 不是一件困难的事，只需要重写 <code>start()</code> 方法，将需要执行的操作写入即可。但如果想要自定义并发 <strong>NSOperation</strong>，需要至少实现以下方法和属性：</p><ul><li><code>start()</code></li><li><code>isAsynchronous</code></li><li><code>isExecuting</code></li><li><code>isFinish</code></li></ul><p>总的来说需要在执行函数的去维护 <strong>NSOperation</strong> 的一些状态，如果还进行了 <strong>KVO</strong> 监听，还需要去发出 <strong>KVO</strong> 通知以反映值的改变。具体可以参考 <strong>Apple</strong> 的文档 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW16">自定义NSOperation 对象</a></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p></blockquote><p>再体会到了多线程的好处之后，需要对数据的安全情况进行保证。线程安全就是为了保证被多线程执行的过程中能够得到正确的结果，即数据不被污染。保证线程安全有「同步」和「非同步」两种方案。「同步」是指在多线程并发访问数据的过程中，保证共享数据在同一时刻只被一个线程使用，例如加锁。「非同步」是指在某些情况下不需要「同步」操作，例如函数本身就不涉及到共享代码，自然也就不需要「同步」去保证数据安全。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h4><p><strong>可重入代码</strong>（<strong>ReentrantCode</strong>）：可以在这个函数执行的任何时刻中断它，转入 **OS **调度下去执行另外一段代码，而返回控制时不会出现什么错误，这意味着它除了使用自己栈上的变量外不依赖于其他任何变量。这种情况每次执行结果都一样，且不会依赖共享变量，在无同步情况下保证了线程安全。</p><p><strong>线程本地存储</strong>：若线程中需要的数据必须与其他线程共享，尝试判断这个共享的数据能否保证只在同一线程执行，如果可以，则可以对该线程创建一份共享变量的副本，这样也可以实现无同步保证线程安全。例如：</p><pre><code class="swift">class Person: NSCopying {    func copy(with zone: NSZone? = nil) -&gt; Any {        return Person(-1, name: "")    }    var age: Int    var name: String    init(_ age: Int, name: String) {        self.age = age        self.name = name    }}var person = Person.init(2, name: "") // 全局变量let queue = DispatchQueue.init(label: "name")for i in 0...100 {    queue.async {        var currPerson = self.person.copy()    }}</code></pre><p>若线程中每次都需要访问 <strong>person</strong>，且在后面不需要同步回原始 <strong>person</strong>，仅在当前线程中操作，也可保证线程安全。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p><strong>互斥同步</strong>：也称非阻塞同步，是指调用返回结果前，当前线程会被挂起进入阻塞状态，只有在得到结果后才继续，是一种悲观的同步策略。在 <strong>iOS</strong> 中以主要以互斥锁方式体现，在获取互斥锁失败后，会进入阻塞状态，等待锁被释放以被唤醒。</p><p><strong>非阻塞同步</strong>：是指在不能得到结果前，当前线程不会进入阻塞状态，是一种乐观的同步策略。在 <strong>iOS</strong> 中以主要以自旋锁的方式体现，在获取锁失败后不会进入阻塞状态，而是不断尝试获取锁，锁被释放，因为不涉及线程状态切换，所以效率高于互斥锁。</p><p>除了锁之外还有的同步工具，如 <strong>Atomic Operations</strong>、<strong>Memory Barries</strong>、<strong>Volatile Variables</strong>，下面进行简要介绍：</p><ul><li><strong>Atomic Operations</strong>：原子操作是一种简单的同步形式，适用于简单的数据结构，它不会阻塞竞争线程；<strong>OS X</strong> 和 <strong>iOS</strong> 包含了许多对 32 位和 64 位值执行基本数学和逻辑运算操作。如<code>atomic_fetch_add</code>、<code>atomic_exchange</code>等，具体可<a href="https://en.cppreference.com/w/c/atomic">参考</a>。</li><li><strong>Memory Barries</strong>：在单线程中，由于硬件会执行必要的记录，以确保程序的内存操作的执行顺序就像代码顺序一样；但是在多线程中，由于编译器为了优化经常对汇编级指令进行重排，就可能会导致产生潜在的错误。内存屏障是一种非阻塞同步工具，用于确保内存操作以正确顺序发生。例如：</li></ul><pre><code class="swift">// thread1:while f == 0 {}print(x)// thread2:x = 5f = 1</code></pre><p>并非每次都打印数字 <strong>5</strong>，如果 <strong>thread2</strong> 乱序执行，先执行 <code>f = 1</code>，后执行 <code>x = 5</code>，则可能会出现意外的值，因此引入了内存屏障，在需要确保执行顺序中插入 <code>OSMemoryBarrier</code>，具体可<a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/OSMemoryBarrier.3.html#//apple_ref/doc/man/3/OSMemoryBarrier">参考</a>。</p><ul><li><strong>Volatile Variables</strong>：声明为 <strong>volatile</strong> 的变量不会被优化。例如变量被编译器优化，被放置于寄存器中并读取，这就有潜在读取风险，而 <strong>volatile</strong> 阻止了这种优化，每次都会从内存中读取变量的当前值。</li></ul><p>内存屏障 和 **volatile **变量都会减少编译器的优化次数，因此只需要在确保正确的地方使用它们。在 <strong>GCD</strong>、 <strong>NSOperation</strong> 中有着许多内存屏障代码，让我们能遇上这种情况微乎其微。</p><h2 id="iOS-中的锁"><a href="#iOS-中的锁" class="headerlink" title="iOS 中的锁"></a>iOS 中的锁</h2><p>在 <strong>iOS</strong> 中，实现线程安全一般以锁来进行线程同步，下面对主要的几种锁进行简要介绍以及性能对比。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><pre><code class="objective-c">@synchronized (obj) {    // 需要同步的代码      NSLog(@"nihao")!}</code></pre><p><strong>@synchronized</strong> 是一个递归锁，其实现采用了 <strong>recursive_mutex_t</strong> ，递归锁即在同一个线程中获取锁多次，只能传递一个 <strong>NSObject</strong> 对象，在 <strong>Swift</strong> 中将此语法移除，将其还原为 <strong>C++</strong> 后可以发现其源码类似如下：</p><pre><code class="objective-c">objc_sync_enter(_sync_obj);// 需同步的代码NSLog(@"nihao")!objc_sync_exit(_sync_obj);</code></pre><p>因此在 <strong>Swift</strong> 中可以利用这两个函数模拟出 <strong>@synchronized</strong></p><pre><code class="swift">func synchronized(lock: AnyObject, closure: () -&gt; Void) {    objc_sync_enter(lock)    closure()    objc_sync_exit(lock)}</code></pre><h3 id="NSLock-amp-NSRecursiveLock"><a href="#NSLock-amp-NSRecursiveLock" class="headerlink" title="NSLock &amp; NSRecursiveLock"></a>NSLock &amp; NSRecursiveLock</h3><pre><code class="swift">let lock = NSLock()lock.lock()// 需同步的代码lock.unlock()let recursiveLock = NSRecursiveLock()recursiveLock.lock()// 需同步的代码recursiveLock.unlock()</code></pre><p><strong>NSLock</strong> 和 <strong>NSRecursiveLock</strong> 在使用上一致，<strong>NSLock</strong> 是一个互斥锁，而 <strong>NSRecursiveLock</strong> 是一个递归锁，都对 <strong>pthread_mutex</strong> 的封装，在使用场景中需考虑是否在同一线程中多次加锁。</p><h3 id="NSCondition-amp-NSConditionLock"><a href="#NSCondition-amp-NSConditionLock" class="headerlink" title="NSCondition &amp; NSConditionLock"></a>NSCondition &amp; NSConditionLock</h3><p><strong>NSCondition</strong> 基于 <code>pthread_mutex</code> 实现，是一个条件锁，其内部维护了一个锁以及一个线程检查器：锁主要是为了同步临界区；线程检查器主要是根据条件决定是否继续运行。</p><ul><li><code>wait()</code>：让当前线程处于等待中</li><li><code>singal()</code>：通知某一个线程从阻塞状态恢复到就绪状态</li><li><code>broadcast()</code>：通知其他所有线程从阻塞状态恢复到就绪状态</li></ul><p>比较常见的例子如生产者消费者模型：</p><pre><code class="swift">var condition = NSCondition() // 锁var money = 5 // 共享变量// thread1func consume() {    condition.lock()    while money == 0 {        condition.wait()    }    money -= 1    condition.unlock()}// thread2func product() {    condition.lock()    money += 1    condition.wait()    condition.unlock()}</code></pre><p><strong>NSConditionLock</strong> 定义了一个互斥锁，可以用于特定的值锁定与解决。其与 <strong>NSCondition</strong> 的行为有些类似，上面的代码可以转换为：</p><pre><code class="swift">var condition = NSConditionLock(condition: 0)var money = 0// 0表示无数据 1表示有数据func consume() {    condition.lock(whenCondition: 1)    money -= 1    condition.unlock(withCondition: money == 0 ? 0 : 1) }func product() {    condition.lock()    money += 1    condition.unlock(withCondition: 1)}</code></pre><h3 id="NSDistrubutedLock"><a href="#NSDistrubutedLock" class="headerlink" title="NSDistrubutedLock"></a>NSDistrubutedLock</h3><p><strong>NSDistrubutedLock</strong> 是一个分布式锁，通常在多个主机上的多个应用程序用来限制对某些共享资源的访问，比如文件，它由文件系统项(例如文件或目录)实现，不过由于 <strong>iOS</strong> 应用的沙盒机制，并未有相应 <strong>API</strong>，在 <strong>OS X</strong> 中可以使用。</p><h3 id="DispatchSemaphore"><a href="#DispatchSemaphore" class="headerlink" title="DispatchSemaphore"></a>DispatchSemaphore</h3><p>上文有对 <strong>DispatchSemaphore</strong> 做介绍，这里就不赘述。</p><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p><strong>OSSpinLock</strong> 是自选锁，但由于 <strong>iOS</strong> 系统中线程可以拥有不同的优先级，可能会产生优先级反转问题。具体来说，在低优先级的线程获得锁并访问共享资源，此时高优先级线程也尝试获取，由于 <strong>OSSpinLock</strong> 是自选锁，它会进入忙等状态并占用大量 <strong>CPU</strong>，进而导致低优先级线程无法与高优先级线程抢占 <strong>CPU</strong>，进而导致任务迟迟无法完成、无法释放 <strong>lock</strong>，因此 <strong>OSSpinLock</strong> 已经被弃用了，使用 <strong>os_unfair_lock</strong> 代替，这也是个互斥锁。</p><pre><code class="objective-c">OSSpinLockLock(&amp;spinlock) // 获取锁，线程一直忙等待。阻塞当前线程执行。OSSpinLockTry(&amp;spinlock) // 尝试获取锁，返回bool。当前线程锁失败，也可以继续其它任务，不阻塞当前线程。OSSpinLockUnlock(&amp;spinlock) // 解锁，参数是OSSpinLock地址。</code></pre><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p><strong>Objective-C</strong> 中属性中的关键字，会对属性的存值与取值进行加锁处理。它是基于<code>os_unfair_lock</code>进行实现，上文提到过，这是一个互斥锁，它不能保证线程安全，只能保证存取值的安全性。</p><h3 id="各种锁的性能比较"><a href="#各种锁的性能比较" class="headerlink" title="各种锁的性能比较"></a>各种锁的性能比较</h3><p>图片截取自 <a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/#more-41952">不再安全的 OSSpinLock</a>，做一个小的推测：</p><p>先讨论锁，然后再分析信号量。</p><p><strong>OSSpinLock</strong> 由于自选锁的特性不会线程状态切换因此排在第一；</p><p>之后的锁都是基于 <strong>POSIX thread</strong> 的相关线程 <strong>API</strong>进行封装，性能根据封装强度不同而有所不同，比如互斥锁性能好于递归锁，同时也好于条件锁；</p><p>信号量其实与锁类似，但<code>pthread_mutex</code>支持多种类型，因此会有额外的判断，就造成了效率略低原因。</p><p>但这些锁虽性能有所差异，但都差距不大，在编码过程中还因考虑具体的场景和代码健壮性等方面。</p><img src="/images/blog/lock_benchmark.png" alt="lock_benchmark" style="zoom:75%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就 <strong>iOS</strong> 中多线程这一点，概述了 <strong>NSThread</strong>、<strong>GCD</strong>、<strong>NSOperation</strong> 这三种多线程使用说明和它们的特点，以及关于线程安全介绍了一些同步手段和关于锁的一些使用。就本人而言，在平时工作中使用 <strong>GCD</strong> 较多，它是多线程编程的核心，应该更多的关注它，同时关于它们的源码，笔者由于水平有限，不能做出较为有理解的看法，就不做过多探讨，希望在后续过程中能够加强这方面的学习。</p><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><ul><li><p>《<strong>Objective-C</strong> 高级编程 - <strong>iOS</strong> 与 <strong>OS X</strong> 多线程和内存管理》</p></li><li><p><a href="https://ming1016.github.io/2016/01/13/how-to-use-gcd/">细说GCD(Grand Central Dispatch)</a></p></li><li><p><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/">关于 @synchronized，这儿比你想知道的还多</a></p></li><li><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1">Threading Programming Guide</a></p></li><li><p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/#more-41952">不再安全的 OSSpinLock</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 多线程 </tag>
            
            <tag> GCD </tag>
            
            <tag> 锁 </tag>
            
            <tag> NSThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 内存模型与方法调度</title>
      <link href="/2022/03/13/SwiftMemoryLayoutMethodDispatch/"/>
      <url>/2022/03/13/SwiftMemoryLayoutMethodDispatch/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从内存分区、内存对齐、内存模型与方法派发角度介绍了关于 Swift 中的一些知识点。</p><span id="more"></span><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>iOS 应用内存分为 5 个区域，其中“全局区”、“常量区” 和 “代码区”的内存空间在编译时确定，“栈”、“堆”的内存空间在运行时确定。</p><p><img src="/images/blog/iOS%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="iOS应用内存分区"></p><ul><li>栈区：存储值类型的局部变量，函数参数，其大小有限，连续分配，向低地址拓展；由在运行时系统自动分配和释放内存空间，每一个线程都有其对应的栈。</li><li>堆区：存储引用类型，不连续的内存区域，向高地址拓展，大小受限于系统中的虚拟内存；由程序员动态创建和释放对象，在运行时分配。</li><li>全局/静态区：存储未初始化的全局变量和静态变量，即 .bss ；和已初始化的全局变量和静态变量，即 .data。</li><li>常量区：存储字符串常量</li><li>代码区：存储程序运行时的代码</li></ul><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><strong>为什么需要内存对齐：</strong></p><ol><li>某些硬件不能随意访问任意地址</li><li>提高访问效率</li></ol><p><strong>内存对齐原则：</strong></p><ol><li>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 <strong>offset</strong> 都是<strong>该成员大小与对齐系数中较小值</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li><li><strong>结构体的总大小</strong>为对齐系数的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</li></ol><p>注：结构体可代替为 <strong>class</strong>、<strong>protocol</strong>等任意类型，只是其他类型内存分布与结构体不同。</p><p>在 <strong>Swift</strong> 中：</p><pre><code class="Swift">MemoryLayout&lt;T&gt;.size // 属性占用大小(与其属性匹配)MemoryLayout&lt;T&gt;.stride // 实际占用大小MemoryLayout&lt;T&gt;.alignment // 对齐系数</code></pre><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a><strong>struct</strong></h3><p>例：</p><pre><code class="swift">struct Foo {    let a: Int8 = 2   // 1 byte    let b: Int16 = 4  // 2 bytes    let c: Int32 = 6  // 4 bytes    let d: Int = 8    // 8 bytes        func foo() {        print("Hello")    }}let foo = Foo()print(MemoryLayout&lt;Foo&gt;.size)print("===end===")</code></pre><img src="/images/blog/image-20220311002137424-6929301.png" alt="image-20211226103015351" style="zoom: 67%;"><p>可以看出，<strong>struct</strong> 的内存是连续分布的，但是由于<strong>内存对齐原则</strong>，属性 <strong>a</strong> 所占用内存空间为 <strong>2 byte</strong>，对于实例方法其内部并不会做存储，而是在编译后直接指向方法的地址。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a><strong>class</strong></h3><p><strong>Swift</strong> 与 <strong>Objective-C</strong> 中的 <strong>Class</strong> 类型，为了兼容 <strong>Objective-C</strong> 且具有更多的 <strong>Swift</strong> 特性，在 <strong>Swift</strong> 源码中，其类型为 <code>swift_class_t</code> 的结构体，继承于 <code>objc_class</code>。其内存布局如下图所示：</p><p><img src="/images/blog/image-20220313210720322-7176842.png" alt="image-20220313210720322"></p><p><strong>isa</strong>：与 <strong>Objective-C</strong> 中 <strong>isa</strong> 一样，包含了这个类型的信息，如 父类的 <strong>isa</strong> 信息、是否存在关联对象、以及 <strong>virtual table</strong> 用以方法调用等内容。</p><p><strong>retain count</strong>：记录其引用计数值</p><h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a><strong>protocol</strong></h3><p>看下面源码</p><pre><code class="swift">protocol Drawable { func draw() }struct Point : Drawable {    var x: Int    var y: Int    func draw() { print("Point") }}struct Line : Drawable {    var x1, y1, x2, y2: Int    func draw() { print("Line") }}class Cricle: Drawable {    var r: Int = 5    func draw() { print("SharedLine") }}struct Simple {    var drawable1: Drawable    var drawable2: Drawable    var drawable3: Drawable    func printMemoryLayout() {        MemoryLayout.size(ofValue: drawable1)        MemoryLayout.size(ofValue: drawable2)        MemoryLayout.size(ofValue: drawable3)    }}</code></pre><p>首先在 <strong>Build Setting</strong> 中，将 <strong>Reflection Metadata Level</strong> 改为 <strong>None</strong>，调用 <code>printMemoryLayout</code> 再进行调试。</p><pre><code>404040</code></pre><p><img src="/images/blog/image-20220313200904959-7173347.png" alt="image-20220313200904959"></p><p><strong>Reflection Metadata Level</strong> 改为 <strong>None</strong>，是防止编译器将反射元数据发送到二进制文件中，会对分析造成干扰。</p><p>对于协议类型来说，为了实现语义上的多态，且创建时其内存大小是不固定的，因此引入了新的内存结构进行处理。</p><p>可以看到输出内存占用大小全部为 40，且都拥有相同的数据结构。如下图所示：</p><p><img src="/images/blog/image-20220311002137424-6929301.png" alt="image-20220311002137424"></p><p><strong>valueBuffer</strong>：3位，对于空间小于或等于 <strong>valueBuffer</strong> 的值，直接存储在 <strong>valueBuffer</strong> 中；对于空间大于 valueBuffer的值，则会在堆中开辟内存空间，<strong>valueBuffer</strong> 则存储其引用地址。对应 <code>drawable1</code> 与 <code>drawable2</code>。</p><p><strong>value witness table</strong>：由于每个协议类型的初始化不尽相同，所以每一种类型(上上图的 <strong>metadata</strong> )都会有一个 <strong>value witness table</strong>，用于进行生命周期管理，有 <code>alloc</code>、<code>copy</code>、<code>destruct</code>、<code>deallocate</code> 等方法。</p><p><strong>protocol witness table</strong>：类似于 <strong>class</strong> 的 <strong>virtual table</strong>，用以存储每个协议类型的方法。每种类型会创造 <code>PWT</code> 表，内部包含指针，指向方法具体实现。</p><h2 id="方法派发"><a href="#方法派发" class="headerlink" title="方法派发"></a>方法派发</h2><p>方法派发是指告诉 <strong>CPU</strong> 如何去找到该函数地址并进行调用的过程，在 <strong>Swift</strong> 中分为 3 种派发机制，分别是静态派发、函数表派发与动态派发。那么什么时候会是什么样的方法派发呢？主要有两方面纬度的考量：</p><h3 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h3><p>对于不同的声明位置来说，其方法派发的是不同的，若下图所示：</p><table><thead><tr><th></th><th>类中声明</th><th>拓展声明</th></tr></thead><tbody><tr><td>value type</td><td>static</td><td>static</td></tr><tr><td>protocol</td><td>table</td><td>static</td></tr><tr><td>class</td><td>table</td><td>static</td></tr><tr><td>NSObject SubClass</td><td>table</td><td>message</td></tr></tbody></table><p><strong>规律：</strong></p><p>值类型都是静态派发</p><p>协议和类中的拓展都是静态派发</p><p><strong>NSObject</strong> 拓展采用消息派发，类中声明采用函数表派发</p><p>协议中默认实现使用函数表派发</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>对于某些关键字来说，也能够改变其派发方式：</p><table><thead><tr><th>关键字</th><th>派发方式</th></tr></thead><tbody><tr><td>final</td><td>static</td></tr><tr><td>dynamic</td><td>Message</td></tr><tr><td>@objc &amp; @nonobjc</td><td>修改 Objective-C 可见性</td></tr><tr><td>@inline</td><td>Static</td></tr></tbody></table><p><strong>规律：</strong></p><p>final - 静态派发</p><p>dynamic - 消息派发</p><p>@objc &amp; @nonobjc - 声明函数能否被 objective-c runtime捕捉到</p><p>final @objc - 调用时静态派发，但会将函数注册到 objective-c runtime中</p><p>@inline - 直接派发，但如果是 dynamic @inline，则会采用消息派发</p><p>结合上两图总结如下：</p><table><thead><tr><th></th><th>直接派发</th><th>函数表派发</th><th>消息派发</th></tr></thead><tbody><tr><td>NSObject</td><td>@nonobjc / final</td><td>类中声明</td><td>拓展申明 且 dynamic</td></tr><tr><td>class</td><td>拓展声明 且 final</td><td>类中声明</td><td>dynamic</td></tr><tr><td>protocol</td><td>拓展声明</td><td>类中声明</td><td>@objc</td></tr><tr><td>value type</td><td>所有方法</td><td>无</td><td>无</td></tr></tbody></table><h3 id="静态派发："><a href="#静态派发：" class="headerlink" title="静态派发："></a><strong>静态派发</strong>：</h3><p>指编译时直接跳转到函数的地址，调用速度最快，同时可能经过编译器优化成 <strong>inline</strong>。</p><p>在 <strong>Swift</strong> 中，值类型的方法调用与 <strong>final</strong> 修饰的是静态派发。（值类型与 <strong>final</strong> 不支持继承与 <strong>override</strong>）</p><h3 id="函数表派发："><a href="#函数表派发：" class="headerlink" title="函数表派发："></a><strong>函数表派发：</strong></h3><p>为在类中申明过的所有方法生成一个函数指针数组</p><p><strong>virtual table / protocol witness table</strong></p><img src="/images/blog/1_4YaI2HPK48IqgyK3DpU_VQ.png" alt="A diagram showing the memory offsets for method1, method2, and method3 in ParentClass and ChildClass." style="zoom:80%;"><p>相较于静态派发，速度更慢，需要两次读取地址与一次跳转，同时编译器无优化操作，将自身作为实例作为隐含参数传递到方法中。例如下面一段协议类型的方法调用的 <strong>SIL</strong> 代码如下：</p><pre><code class="swift">// drawACopy(drawables:)sil hidden @$s14ViewController9drawACopy9drawablesyAA8Drawable_p_tF : $@convention(thin) (@in_guaranteed Drawable) -&gt; () {// %0 "drawables"                                 // users: %2, %1bb0(%0 : $*Drawable):  debug_value_addr %0 : $*Drawable, let, name "drawables", argno 1 // id: %1  %2 = open_existential_addr immutable_access %0 : $*Drawable to $*@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable // users: %4, %4, %3  %3 = witness_method $@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable, #Drawable.draw : &lt;Self where Self : Drawable&gt; (Self) -&gt; () -&gt; (), %2 : $*@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable : $@convention(witness_method: Drawable) &lt;τ_0_0 where τ_0_0 : Drawable&gt; (@in_guaranteed τ_0_0) -&gt; () // type-defs: %2; user: %4  %4 = apply %3&lt;@opened("F57086CE-A07E-11EC-86EE-ACDE48001122") Drawable&gt;(%2) : $@convention(witness_method: Drawable) &lt;τ_0_0 where τ_0_0 : Drawable&gt; (@in_guaranteed τ_0_0) -&gt; () // type-defs: %2  %5 = tuple ()                                   // user: %6  return %5 : $()                                 // id: %6} // end sil function '$s14ViewController9drawACopy9drawablesyAA8Drawable_p_tF'</code></pre><p>可以看到对于协议类型，会通过 <code>open_existential_addr</code> 创建一个局部变量 <code>%2</code>，在通过 <code>%2</code> 找到其对应<code>witness_method</code> - <code>%3</code>，最后再通过 <code>%2</code> 与作为入参执行方法 （<code>apply</code>） <code>%3</code>。</p><h3 id="动态派发："><a href="#动态派发：" class="headerlink" title="动态派发："></a>动态派发：</h3><p>与 <strong>Objective-C</strong> 一致，会被翻译成 <strong>objc_send</strong> 这样的代码，会经过 <strong>cache</strong> 查找、通过 <strong>isa</strong> 指针在当前类与父类的 <strong>method_list</strong> 查找、最后到消息转发流程。动态派发的速度最慢，但可功能性最强。</p><p>网上关于动态派发的文章很多，这里不再赘述，详情参考：<a href="https://juejin.cn/post/6844903575437606920#heading-6">iOS 消息发送与转发详解</a></p><h2 id="🔗"><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2><p><a href="https://www.jianshu.com/p/e5a54813b93d">iOS-底层原理 24: 内存5大区</a></p><p><a href="https://swiftunboxed.com/internals/size-stride-alignment/">Size, Stride, Alignment</a></p><p><a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/Swift/Method%20Dispatch%20and%20Memory%20Layout.md#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">Swift 方法调度与内存布局</a></p><p><a href="https://zhuanlan.zhihu.com/p/35696161">Swift 中的方法调用（Method Dispatch）（一） - 概述</a></p><p><a href="https://juejin.cn/post/6968799729853399053#note3">[译] Swift 中的方法派发</a></p><p><a href="https://www.rightpoint.com/rplabs/switch-method-dispatch-table">switch-method-dispatch-table</a></p><p><a href="https://academy.realm.io/posts/goto-mike-ash-exploring-swift-memory-layout/">Exploring Swift Memory Layout</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 启动优化</title>
      <link href="/2022/03/07/iOS%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
      <url>/2022/03/07/iOS%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-启动优化"><a href="#iOS-启动优化" class="headerlink" title="iOS 启动优化"></a>iOS 启动优化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>启动时间往往是一个用户对 APP 的第一影响，如何优化启动时间一直都是个老生常谈的问题。本文结合了 WWDC16、WWDC17与WWDC19的相关 Session 与借鉴老司机的博客，梳理了启动阶段、dyld变化、Mach-O、虚拟内存等内容，简要阐述了如何优化与检测启动时间。</p><span id="more"></span><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><h3 id="启动类型"><a href="#启动类型" class="headerlink" title="启动类型"></a>启动类型</h3><ul><li><p>冷启动</p><ul><li>重启后 / APP 很长时间为启动过</li><li>将它从磁盘加载到内存</li><li>启动支撑 APP 运行的系统侧服务(system-side service)</li><li>创建 APP 进程</li></ul></li><li><p>热启动</p><ul><li>APP 最近启动过</li><li>由于有APP部分与系统侧服务在内存中，所以会比冷启动快一些。</li></ul></li></ul><h3 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h3><ul><li><p>main 函数之前</p><ul><li><p>加载可执行文件</p></li><li><p>dyld 加载 dylibs，进行 rebase 指针调整 与 bind 符号绑定。</p><ul><li>rebase: 修正指向当前 Mach-O 文件的指针。所需要的指针信息已经被编码到 __LINKEDIT 里，然后就是不断重复的对 __DATA 的指针加上这个偏移量。</li><li>bind: 对调用外部符号进行绑定处理。</li></ul></li><li><p>Runtime 初始化</p></li></ul></li><li><p>main 函数之后</p><ul><li><p>实例化 UIApplication 与 UIApplicationDelegate </p></li><li><p>开始事件处理与系统集成</p></li><li><p>调用 UIApplicationDelegate 中生命周期方法</p><ul><li>普通：<br>application:willFinishLaunchingWithOptions:<br>application:didFinishLaunchingWithOptions:<br>applicationDidBecomeActive:</li><li>针对 UISceneDelegate：<br>application:willFinishLaunchingWithOptions:<br>application:didFinishLaunchingWithOptions:<br>scene:willConnectToSession:options:<br>sceneWillEnterForeground:<br>sceneDidBecomeActive:</li></ul></li><li><p>首屏渲染</p><ul><li>loadView</li><li>viewDidLoad</li><li>layoutSubViews</li></ul></li><li><p>异步获取数据并呈现给用户</p></li></ul></li></ul><h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><h3 id="dyld-1-x"><a href="#dyld-1-x" class="headerlink" title="dyld 1.x"></a>dyld 1.x</h3><ul><li>1996 - 2004</li><li>包含在 NeXTStep 3.0 中，不能很好支持相同语义同时一些边界条件无法正常运作。</li><li>预绑定(PreBuilding)：为 dylib 和 App 找到合适的固定地址，每次启动都会有。</li></ul><h3 id="dyld-2-x"><a href="#dyld-2-x" class="headerlink" title="dyld 2.x"></a>dyld 2.x</h3><ul><li><p>2004 - 2017</p></li><li><p>特性</p><ul><li><p>Codesign</p><ul><li>以页为单位，Mach-O 文件的每一页都要被 hash，在被载入时进行与  __LINKEDIT 中的信息进行校验。</li></ul></li><li><p>ASLR</p><ul><li>Mach-O 文件被加载到随机的地址上。</li></ul></li><li><p>Bounds Checking</p><ul><li>避免恶意的二进制文件的加入。</li></ul></li><li><p>Shared cache</p><ul><li>共享缓存是包含所有系统 dylib 的单个文件，代替了 PreBuilding。</li></ul></li></ul></li><li><p>流程</p><ul><li>解析 Mach-O 的 Header 与 Load Commands，递归加载其依赖的动态库。</li><li>映射所有 Mach-O 文件到 App 的地址空间。</li><li>符号查找</li><li>Rebase &amp; Bind</li><li>运行初始化程序</li></ul></li></ul><h3 id="dyld-3-x"><a href="#dyld-3-x" class="headerlink" title="dyld 3.x"></a>dyld 3.x</h3><ul><li><p>2017 - 至今</p></li><li><p>可缓存阶段 “解析Mach-O文件、找到对应依赖库、执行符号查找”，除了软件更新或者更改了磁盘上的库，负责每次启动的App依赖库符号不变、库中符号始终处于相同偏移量。因此将可缓存挪到了最前面，并将执行结果以闭包形式写入到磁盘。</p></li><li><p>dyld 被分为 3 个组件</p><ul><li>进程外的 Mach-O 解析器 / 编译器</li><li>进程内的引擎，用来启动闭包缓存</li><li>启动闭包缓存服务</li></ul></li><li><p>流程</p><ul><li>解析 Mach-O文件</li><li>找到所有依赖库</li><li>符号查找</li><li>读取启动闭包</li><li>验证启动闭包</li><li>映射 Mach-O 文件到 App的地址空间</li><li>Rebase &amp; Bind</li><li>运行初始化程序</li></ul></li></ul><h2 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h2><h3 id="Mach-O-是系统不同运行时期可执行文件的文件类型统称，主要分为-3-种"><a href="#Mach-O-是系统不同运行时期可执行文件的文件类型统称，主要分为-3-种" class="headerlink" title="Mach-O 是系统不同运行时期可执行文件的文件类型统称，主要分为 3 种"></a>Mach-O 是系统不同运行时期可执行文件的文件类型统称，主要分为 3 种</h3><ul><li>Executable：可执行文件，是 APP 中的主要 2 进制文件</li><li>Dylib：动态库，在其他平台也叫 DSO / DLL</li><li>Bundle：苹果平台特有的类型，是无法被链接的 Dylib。是能在运行时通过 dlopen() 加载</li></ul><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><ul><li><p>Header：包含了 Mach-O 文件的基本信息。如：CPU 架构、文件类型、加载指令数量等</p></li><li><p>Load Commands：跟在 Header 后面的加载命令区，包含文件的组织架构、在虚拟内存的布局方式，在调用时知道如何设置和加载二进制文件。</p></li><li><p>Data：包含 Load Commands 中需要的各个  Segment 的数据。</p></li><li><p>绝大多数 Mach-O 包含以下三种类型的 Segment</p><ul><li>__TEXT：代码段，包含头文件、代码、常量。只读不可修改</li><li>__DATA：数据段，包含全局变量、静态变量。可读可写</li><li>__LINKEDIT：如何加载程序，包含方法和变量的元数据(位置、偏移量)，以及代码签名等信息。只读不可修改</li></ul></li></ul><h3 id="Mach-O-Universal-Files"><a href="#Mach-O-Universal-Files" class="headerlink" title="Mach-O Universal  Files"></a>Mach-O Universal  Files</h3><ul><li>支持多个架构的 Mach-O 文件通常被称为通用二进制文件，也称胖二进制文件。</li><li>胖二进制文件起始处有一个 Fat Header，包含所有的架构以及它们在文件中的偏移量。</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。"><a href="#虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。" class="headerlink" title="虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。"></a>虚拟内存是建立在物理内存和进程之间的中间层。是一个连续的逻辑地址空间，而且逻辑地址可以没有对应的实际物理地址，也可以让多个逻辑地址对应到同一个物理地址上。</h3><h3 id="缺页中断-Page-Fault"><a href="#缺页中断-Page-Fault" class="headerlink" title="缺页中断(Page Fault)"></a>缺页中断(Page Fault)</h3><ul><li>当进程访问一个没有对应物理地址的逻辑地址时，会发生 Page Fault</li></ul><h3 id="懒加载-Lazy-Reading"><a href="#懒加载-Lazy-Reading" class="headerlink" title="懒加载(Lazy Reading)"></a>懒加载(Lazy Reading)</h3><ul><li>某个想要读取的页没有存在于内存会触发 Page Fault，系统通过 mmap() 函数读取指定页，这个过程成为 Lazy Reading。mmap() 函数可以将文件的部分内容映射到地址范围，而不是整个文件。</li></ul><h3 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h3><ul><li>当进程需要对某一页的内容进行修改时，内核会把需要修改的部分先复制一份，然后再修改，那个重新把逻辑地址映射到物理地址上去。</li></ul><h3 id="Dirty-Page-amp-Clean-Page"><a href="#Dirty-Page-amp-Clean-Page" class="headerlink" title="Dirty Page &amp; Clean Page"></a>Dirty Page &amp; Clean Page</h3><ul><li>Dirty Page：包含特定进程信息的页</li><li>Clean Page：不包含特定进程信息的页。如果需要，内核可以重新生成 Clean Page。</li></ul><h3 id="共享内存-Shared-RAM"><a href="#共享内存-Shared-RAM" class="headerlink" title="共享内存(Shared RAM)"></a>共享内存(Shared RAM)</h3><ul><li>当多个 Mach-O 依赖同一个 Dylib(eg. UIKit) 时，系统会让几个 Mach-O 的调用 Dylib 的逻辑地址指向同一块物理内存空间，从而实现内存共享。Dirty Page 为进程独有，不能被共享。</li></ul><h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><p>减少动态库或将多个动态库合并成一个</p><p>减少静态初始化</p><p>+load 方法内容放到首屏渲染后再执行，或使用 +initialize() 方法替换。</p><p>在 didFinishLaunchingWithOptions 和首屏渲染中只保留必要的初始化任务。</p><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>hook</p><p>Instrument - App Lunch / 本地测量</p><p>Organizer - Launch Time / 线上数据</p><p>启动参数- DYLD_PRINT_STATISTICS=ture</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xiaozhuanlan.com/topic/4690823715">老司机技术周报 - 优化 APP 启动</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/423/">WWDC19 / 423 - 优化 APP 启动</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2017/413">WWDC17 / 413 - App 启动时间: 过去、现在和将来</a></p><p><a href="https://huang-libo.github.io/posts/Optimizing-App-Startup-Time/#%E7%9B%AE%E5%BD%95">WWDC16 / 406 - 优化 App 启动时间</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 编译流程</title>
      <link href="/2022/02/07/2022-02-07-Swift%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/02/07/2022-02-07-Swift%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift-编译过程"><a href="#Swift-编译过程" class="headerlink" title="Swift 编译过程"></a>Swift 编译过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上文，本文将介绍 <strong>Swift</strong> 语言的编译主要前端流程，后端的流程与上文同步，就不过多赘述，详情见 <a href="https://xuhaodong1.github.io/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">iOS 编译过程</a>，同时本文就 <strong>SIL</strong> 介绍其特点。</p><span id="more"></span><h2 id="Clang-与-SwiftC"><a href="#Clang-与-SwiftC" class="headerlink" title="Clang 与 SwiftC"></a>Clang 与 SwiftC</h2><p>为什么要引入一种新的编译器，整体而言 <strong>Swift</strong> 作为一种高级语言，其很多高级特性 <strong>Clang</strong> 不支持，同时也由于 <strong>Clang</strong> 自身的一些弊端。进而催生出了 <strong>SwiftC</strong>，将 <strong>Clang</strong> 和 <strong>SwiftC</strong> 的编译流程进行对比：</p><p>其中 <strong>Clang</strong> 的劣势如下：</p><ul><li>语义不可重复表示，导致予以分析会依赖于 Parse(可看成生成 <strong>token</strong> 表，进行词法分析)。</li><li>IR 中间代码不适用于进行 <strong>Analysis</strong>，采用 <strong>CFG</strong> 进行分析，导致生成 <strong>IR</strong> 和 <strong>Analysis</strong> 是两部分 （Analysis 有别与词语分析与语法分析，它单独对源代码进行分析，如查找【不会执行的代码】、【不会被初始化的变量】、【静态分析】等）。</li><li>在 <strong>CFG</strong> 和 <strong>IR</strong> 降级的时候会做很多重复分析，做无用功。</li></ul><p>相较而言 <strong>Swift</strong> 解决了 <strong>Clang</strong> 中的很多问题，引入了 <strong>SIL</strong>（ <strong>Swift Intermediate Language</strong> ） 中间代码，既可进行 分析 又可进行 <strong>IR</strong> 代码生成，并引入了许多新的高级优化特性。</p><p><img src="/images/blog/webp.png" alt="img"></p><p><img src="/images/blog/Swift%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png" alt="img"></p><h2 id="SwiftC-编译流程-Frontend"><a href="#SwiftC-编译流程-Frontend" class="headerlink" title="SwiftC 编译流程(Frontend)"></a>SwiftC 编译流程(Frontend)</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h3><pre><code class="swift">class Person {    var name = "nihao"    func getName() -&gt; String {        print(name)        return name    }}</code></pre><h3 id="Parse-词法分析"><a href="#Parse-词法分析" class="headerlink" title="Parse(词法分析):"></a>Parse(词法分析):</h3><p>命令：<code>swiftc -dump-parse main.swift &gt;&gt; ./main.parse</code></p><pre><code class="shell">(source_file "main.swift"  (class_decl range=[main.swift:8:1 - line:15:1] "Person"    (pattern_binding_decl range=[main.swift:9:5 - line:9:16]      (pattern_named 'name')      Original init:      (string_literal_expr type='&lt;null&gt;' encoding=utf8 value="nihao" builtin_initializer=**NULL** initializer=**NULL**)      Processed init:      (string_literal_expr type='&lt;null&gt;' encoding=utf8 value="nihao" builtin_initializer=**NULL** initializer=**NULL**))    (var_decl range=[main.swift:9:9 - line:9:9] "name" type='&lt;null type&gt;')    (func_decl range=[main.swift:11:5 - line:14:5] "getName()"      (parameter "self")      (parameter_list range=[main.swift:11:17 - line:11:18])      (result        (type_ident          (component id='String' bind=none)))      (brace_stmt range=[main.swift:11:30 - line:14:5]        (call_expr type='&lt;null&gt;' arg_labels=_:          (unresolved_decl_ref_expr type='&lt;null&gt;' name=print function_ref=unapplied)          (paren_expr type='&lt;null&gt;'            (unresolved_decl_ref_expr type='&lt;null&gt;' name=name function_ref=unapplied)))        (return_stmt range=[main.swift:13:9 - line:13:16]          (unresolved_decl_ref_expr type='&lt;null&gt;' name=name function_ref=unapplied))))))</code></pre><p>可以看到有别于 Clang 生成 token 流的的形式，Parse阶段是一个递归至顶向下的解析过程，这也解释了其语义可重复表示的原因。</p><h3 id="语义分析并生成AST"><a href="#语义分析并生成AST" class="headerlink" title="语义分析并生成AST"></a>语义分析并生成AST</h3><p>命令：<code>swiftc -dump-ast main.swift &gt;&gt; ./main.ast</code></p><pre><code class="shell">(source_file "main.swift"  (class_decl range=[main.swift:8:1 - line:15:1] "Person" interface type='Person.Type' access=internal non-resilient    (pattern_binding_decl range=[main.swift:9:5 - line:9:16]      (pattern_named type='String' 'name')      Original init:      (string_literal_expr type='String' location=main.swift:9:16 range=[main.swift:9:16 - line:9:16] encoding=utf8 value="nihao" builtin_initializer=Swift.(file).String extension.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) initializer=**NULL**)      Processed init:      (string_literal_expr type='String' location=main.swift:9:16 range=[main.swift:9:16 - line:9:16] encoding=utf8 value="nihao" builtin_initializer=Swift.(file).String extension.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) initializer=**NULL**))    (var_decl range=[main.swift:9:9 - line:9:9] "name" type='String' interface type='String' access=internal readImpl=stored writeImpl=stored readWriteImpl=stored      (accessor_decl implicit range=[main.swift:9:9 - line:9:9] 'anonname=0x7fcbc202f0d8' interface type='(Person) -&gt; () -&gt; String' access=internal get_for=name        (parameter "self" type='Person' interface type='Person')        (parameter_list)        (brace_stmt implicit range=[main.swift:9:9 - line:9:9]          (return_stmt implicit            (member_ref_expr implicit type='String' decl=main.(file).Person.name@main.swift:9:9 direct_to_storage              (declref_expr implicit type='Person' decl=main.(file).Person.&lt;anonymous&gt;.self@main.swift:9:9 function_ref=unapplied)))))      (accessor_decl implicit range=[main.swift:9:9 - line:9:9] 'anonname=0x7fcbc202f330' interface type='(Person) -&gt; (String) -&gt; ()' access=internal set_for=name        (parameter "self" type='Person' interface type='Person')        (parameter_list range=[main.swift:9:9 - line:9:9]          (parameter "value" type='String' interface type='String'))......</code></pre><p>此步进行语法分析，并生成抽象语法树，可以看到生成的 AST 与 Parse 阶段的产于语法一直，不过在其基础上补充了很多内容，如类型、访问权限、构造函数、析构函数等。</p><h3 id="Raw-原始-SIL-生成"><a href="#Raw-原始-SIL-生成" class="headerlink" title="Raw(原始) SIL 生成"></a>Raw(原始) SIL 生成</h3><p>命令：<code>swiftc -emit-silgen main.swift &gt;&gt; ./main.silgen</code></p><pre><code class="swift">sil_stage rawimport Builtinimport Swiftimport SwiftShimsclass Person {  @_hasStorage @_hasInitialValue var name: String { get set }  func getName() -&gt; String  @objc deinit  init()}// mainsil [ossa] @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):  %2 = integer_literal $Builtin.Int32, 0          // user: %3  %3 = struct $Int32 (%2 : $Builtin.Int32)        // user: %4  return %3 : $Int32                              // id: %4} // end sil function 'main'// variable initialization expression of Person.namesil hidden [transparent] [ossa] @$s4main6PersonC4nameSSvpfi : $@convention(thin) () -&gt; @owned String {bb0:  %0 = string_literal utf8 "nihao"                // user: %5  %1 = integer_literal $Builtin.Word, 5           // user: %5  %2 = integer_literal $Builtin.Int1, -1          // user: %5  %3 = metatype $@thin String.Type                // user: %5  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %5  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %6  return %5 : $String                             // id: %6} // end sil function '$s4main6PersonC4nameSSvpfi'    ......</code></pre><p><strong>Raw SIL</strong>，由于 目前的 <strong>SIL</strong> 还未进行确保优化与诊断检查，此时的 <strong>SIL</strong> 还比较脆弱，所以称其为 <strong>Raw SIL</strong>。</p><h3 id="Canonical-正式-SIL生成"><a href="#Canonical-正式-SIL生成" class="headerlink" title="Canonical(正式) SIL生成"></a>Canonical(正式) SIL生成</h3><p>命令：<code>swiftc -emit-sil main.swift &gt;&gt; ./main.sil</code></p><pre><code class="Swift">sil_stage canonicalimport Builtinimport Swiftimport SwiftShimsclass Person {  @_hasStorage @_hasInitialValue var name: String { get set }  func getName() -&gt; String  @objc deinit  init()}// mainsil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 {bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):  %2 = integer_literal $Builtin.Int32, 0          // user: %3  %3 = struct $Int32 (%2 : $Builtin.Int32)        // user: %4  return %3 : $Int32                              // id: %4} // end sil function 'main'// variable initialization expression of Person.namesil hidden [transparent] @$s4main6PersonC4nameSSvpfi : $@convention(thin) () -&gt; @owned String {bb0:  %0 = string_literal utf8 "nihao"                // user: %5  %1 = integer_literal $Builtin.Word, 5           // user: %5  %2 = integer_literal $Builtin.Int1, -1          // user: %5  %3 = metatype $@thin String.Type                // user: %5  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)  %4 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %5  %5 = apply %4(%0, %1, %2, %3) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String // user: %6  return %5 : $String                             // id: %6} // end sil function '$s4main6PersonC4nameSSvpfi'// String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)sil [always_inline] [readonly] [_semantics "string.makeUTF8"] @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -&gt; @owned String......</code></pre><p>这一步主要进行确保优化以及诊断检查工作：</p><p>特定流程：</p><ul><li><strong>强制内联</strong>：对于透明函数进行内联(透明函数：如果一个函数值受到入参的变化，每次调用相同的入参会有相同的返回值。)</li><li><strong>内存提升</strong>：1. 将<code>alloc_box</code>结构优化为<code>alloc_stack</code> 2. 提升无暴露地址(<code>non_address-exposed</code>)的<code>alloc_stack</code>说明到SSA注册。</li><li><strong>常数传播</strong>：一种优化常数手段，如表达式可以在编译器求值；常量值可代替常量变量；过程的部分参数是常量，减少涉及状态向量的大小可以避免代码的扩展等内容。具体可参考<a href="https://blog.csdn.net/qq_36287943/article/details/104974597">这里</a>。</li><li><strong>返回分析</strong>：验证每个方法在每个代码路径只返回一个值，并且不会在定义的末端出现无返回值的错误。</li><li><strong>临界拆分</strong>：不支持任意的基础block参数通过终端进行临界拆分，使得运算更加高效。</li></ul><h3 id="优化SIL"><a href="#优化SIL" class="headerlink" title="优化SIL"></a>优化SIL</h3><p>命令：<code>swiftc -emit-sil main.swift &gt;&gt; ./main.sil -O</code></p><p>也是在与上一步命令相同，但加上 -O参数，这一步不是必要的，如果在 <strong>Xcode</strong> 中设置 -Onone，则不会进行。</p><p>特定优化：</p><ul><li>泛型特化：分析泛型函数的特定调用，并生成新的特定版本的函数，将泛型的特定用法全部重写为对应的特定函数调用。</li><li><strong>witness</strong>和虚函数表的去虚拟化：通过给定类型去查找关联的类的虚函数表或者类型的witness表，并将虚函数调用替换为调用函数映射，简化了查找流程从而提高了效率。</li><li><strong>性能内联</strong></li><li><strong>引用计数优化</strong></li><li><strong>内存提升/优化</strong></li><li><strong>高级领域特定优化</strong>：swift编译器对基础的swift类型容器(类似Array或String)实现了高级优化，如 <strong>Copy On Wirte</strong>。</li></ul><h3 id="IR代码生成"><a href="#IR代码生成" class="headerlink" title="IR代码生成"></a>IR代码生成</h3><p>命令：<code>swiftc -emit-ir main.swift &gt;&gt; ./main.ir</code></p><pre><code class="swift">; ModuleID = '&lt;swift-imported-modules&gt;'source_filename = "&lt;swift-imported-modules&gt;"target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx12.0.0"%T4main6PersonC = type &lt;{ %swift.refcounted, %TSS }&gt;%swift.refcounted = type { %swift.type*, i64 }%swift.type = type { i64 }%TSS = type &lt;{ %Ts11_StringGutsV }&gt;%Ts11_StringGutsV = type &lt;{ %Ts13_StringObjectV }&gt;%Ts13_StringObjectV = type &lt;{ %Ts6UInt64V, %swift.bridge* }&gt;%Ts6UInt64V = type &lt;{ i64 }&gt;%swift.bridge = type opaque%swift.full_type = type { i8**, %swift.type }%objc_class = type { %objc_class*, %objc_class*, %swift.opaque*, %swift.opaque*, i64 }%swift.opaque = type opaque%swift.method_descriptor = type { i32, i32 }%swift.type_metadata_record = type { i32 }%swift.metadata_response = type { %swift.type*, i64 }%"$s4main6PersonC4nameSSvM.Frame" = type { [24 x i8] }%Any = type { [24 x i8], %swift.type* }%TSa = type &lt;{ %Ts12_ArrayBufferV }&gt;%Ts12_ArrayBufferV = type &lt;{ %Ts14_BridgeStorageV }&gt;%Ts14_BridgeStorageV = type &lt;{ %swift.bridge* }&gt;</code></pre><p>可以看到，生成的语法结构和 <strong>Objective-C</strong> 文件生成的结构一致。</p><p>至此，<strong>SwiftC</strong> 编译流程就已经全部梳理完了，其中还有 <strong>clang importer</strong> 模块的工作并未介绍，<strong>clang importer</strong> 负责导入 <strong>Clang</strong> 模块，并将 <strong>C</strong> 或 <strong>Objective-C</strong> 的API映射到 <strong>Swift API</strong> 中。</p><h2 id="SIL-介绍"><a href="#SIL-介绍" class="headerlink" title="SIL 介绍"></a>SIL 介绍</h2><p><strong>Swift</strong> 中间语言（Swift Intermediate Language，SIL）是一门高级且专用于 Swift 的中间语言，适用于对 Swift 代码的进一步分析和优化。SIL 依赖于 Swift 的类型系统和声明，所以 SIL 语法是 Swift 的延伸。一个 <code>.sil</code> 文件是一个增加了 SIL 定义的 Swift 源文件。 <code>.swift</code> 源文件只针对声明进行语法分析，其 <code>func</code> 方法体和最高阶代码将会被 SIL 语法分析器忽略。 在 <code>.sil</code> 文件中没有隐式 import。如果使用 swift 或者 Buildin 标准组件的话必须明确的引用。</p><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>地址类型 <code>$*T</code> 指针指向的是任意引用的值或者 <code>$T</code>。地址不是引用计数指针，不能被 <code>retained</code> 或<code>released</code>。</p><h3 id="Box类型"><a href="#Box类型" class="headerlink" title="Box类型"></a>Box类型</h3><p>本地变量和非直接的数值类型都是存储在堆上，@box T 是一个引用计数类型，指向的是包含了多个 T 的盒子。盒子使用的是 Swift 的原生引用计数。</p><h3 id="Metatype-类型"><a href="#Metatype-类型" class="headerlink" title="Metatype 类型"></a>Metatype 类型</h3><p>SIL 内的 <code>metatype</code> 类型必须描述自身表示：</p><ul><li><code>@thin</code> 表示不需要内存空间</li><li><code>@thick</code> 指存储的是类型的引用或者类型子类的引用</li><li><code>@objc</code> 指存储的是一个 OC 类对象的表示。</li></ul><h3 id="VTables"><a href="#VTables" class="headerlink" title="VTables"></a>VTables</h3><p>用来表示类对象方法的动态派发，如果看到 SIL 代码中出现 <code>class_method</code> 或者 <code>super_method</code>，这些都是通过 <code>sil_vtable</code> 进行追踪的；<code>sil_table</code> 中包含类对象中的所有方法的映射，包括从父对象继承的方法。</p><h3 id="Witness-Table"><a href="#Witness-Table" class="headerlink" title="Witness Table"></a>Witness Table</h3><p>用来代表泛型类型的方法动态派发，一个泛型类型的所有的所有泛型实例共享一个 <code>Witness Table</code>，同样衍生类也都会集成基类的 <code>Witness Table</code>。</p><p>每个遵循协议的对象都会有一个唯一标识，会生成一张 <code>Witness table</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 Swift 的编译流程，可以看出，Swift 作为一种高级的安全类型语言，编译器对其做了许多优化，算是弥补了对 Clang 许多不足。SIL 是 Swift 编译的重点，从中可以窥探一些平时开发中难以琢磨的问题，如方法派发、引用计数等内容。以下附swiftc 的命令行帮助。</p><pre><code class="shell">USAGE: swiftcMODES:  -dump-ast               Parse and type-check input file(s) and dump AST(s)  -dump-parse             Parse input file(s) and dump AST(s)  -dump-pcm               Dump debugging information about a precompiled Clang module  -dump-scope-maps &lt;expanded-or-list-of-line:column&gt;                          Parse and type-check input file(s) and dump the scope map(s)  -dump-type-info         Output YAML dump of fixed-size types from all imported modules  -dump-type-refinement-contexts                          Type-check input file(s) and dump type refinement contexts(s)  -emit-assembly          Emit assembly file(s) (-S)  -emit-bc                Emit LLVM BC file(s)  -emit-executable        Emit a linked executable  -emit-imported-modules  Emit a list of the imported modules  -emit-irgen             Emit LLVM IR file(s) before LLVM optimizations  -emit-ir                Emit LLVM IR file(s) after LLVM optimizations  -emit-library           Emit a linked library  -emit-object            Emit object file(s) (-c)  -emit-pcm               Emit a precompiled Clang module from a module map  -emit-sibgen            Emit serialized AST + raw SIL file(s)  -emit-sib               Emit serialized AST + canonical SIL file(s)  -emit-silgen            Emit raw SIL file(s)  -emit-sil               Emit canonical SIL file(s)  -emit-supported-features                          Emit a JSON file including all supported compiler features  -index-file             Produce index data for a source file  -parse                  Parse input file(s)  -print-ast              Parse and type-check input file(s) and pretty print AST(s)  -resolve-imports        Parse and resolve imports in input file(s)  -scan-dependencies      Scan dependencies of the given Swift sources  -typecheck              Parse and type-check input file(s)</code></pre><p>🔗：</p><p><a href="https://www.jianshu.com/p/c2880460c6cd">Swift的高级中间语言：SIL</a></p><p><a href="https://www.swift.org/swift-compiler/">Swift-Compiler 官方</a></p><p><a href="https://zhuanlan.zhihu.com/p/353732257">Swift - 源码编译</a></p><p><a href="https://blog.csdn.net/qq_36287943/article/details/104974597">编译优化之 - 常数传播入门</a></p><p><a href="https://github.com/apple/swift/blob/2ddc92a51a4c6d216a9b2dc3a2e41e9b592afbdf/docs/SIL.rst">Apple - Swift Intermediate Language</a></p><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147">深入浅出iOS编译</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compile </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 编译过程</title>
      <link href="/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/11/03/2021-11-03-iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-编译过程"><a href="#iOS-编译过程" class="headerlink" title="iOS 编译过程"></a>iOS 编译过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 <strong>iOS</strong> 编译过程（<strong>Compile</strong>）有助于我们更好理解代码是如何被计算机运作起来，编译器为代码做了哪些优化，让我们学会从另一个角度来看待问题。</p><span id="more"></span><h2 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h2><p>现代编译器是将源代码转换成可执行文件的程序，工作流程主要分为 <strong>前端</strong> 和 <strong>后端</strong> 两个部分：</p><ol><li>前端：对源代码进行解析，并生成中间代码。</li><li>后端：针对中间代码进行优化，并转换成目标机器的代码指令。</li></ol><pre class="mermaid">graph LR    A(SourceCode) --&gt; B(Frontend)    B(Frontend) --&gt; C(Backend)    C(Backend) --&gt; D(Machine Code)</pre><p>针对iOS平台，不同语言采用了不同的编译器前端：</p><ol><li><p><strong>Frontend：Clang / SwiftC</strong></p><p>对于 <strong>Objective-C / C / C++ / Objective-C++</strong>  来说采用 <strong>Clang</strong> 编译器前端；</p><p>对于 <strong>Swift</strong> 来说则采用 <strong>SwiftC</strong>；</p></li><li><p><strong>Backend：LLVM</strong></p><p>无论是 <strong>C</strong> 系语言还是 <strong>Swift</strong> 都采用 <strong>LLVM</strong> 作为编译器后端；</p></li></ol><p>值得注意的是在 <strong>Xcode3</strong> 以前，都采用 <strong>GCC</strong> 作为编译器前端，但为 <strong>Apple</strong> 快速发展需要功能更强大和性能更好的编译器，所以 <strong>Apple</strong> 自己开发了 <strong>Clang</strong> 作为编译器前端。下面对编译器做一个简要介绍：</p><ul><li><strong>GCC</strong></li></ul><p><strong>GCC</strong>（<strong>GNU Compile Collection</strong>，**GNU **编译器套装），是一套由 <strong>GNU</strong> 开发的编程语言编译器。来本只能处理 <em>C</em> 语言，后来快速演进，变得可处理 <strong>C++、Objective-C、Java、Fortran</strong> 等其他语言。但由于一些缺陷，导致了 <strong>Apple</strong> 抛弃了 <strong>GCC</strong> ，开发出了 <strong>Clang</strong> 作为其前端编译器。</p><ol><li><strong>GCC</strong> 的 <strong>Objective-C Frontend</strong> 不是 <strong>Apple</strong> 维护，导致想要添加一些语法提示等功能得去要求 <strong>GCC</strong> 团队做。</li><li><strong>GCC</strong> 的插件、工具、<strong>IDE</strong> 的支持薄弱。</li><li><strong>GCC</strong> 的编译效率和性能不足。</li></ol><ul><li><strong>Clang</strong></li></ul><p><strong>Clang1.0</strong> 于 <strong>2009</strong> 年正式与 <strong>LLVM2.6</strong> 正式发布，旨在提供 <strong>GCC</strong> 的替代品，支持了 <strong>GUN</strong> 编译器大多数的编译器设置以及非官方语言的拓展，相较于 <strong>GCC</strong> ，<strong>Clang</strong> 具有以下优势：</p><ol><li>编译速度更快。</li><li>占用内存更小。</li><li>模块化设计，易于拓展与重用。</li><li>诊断信息可读性强。</li></ol><ul><li><strong>SwiftC</strong></li></ul><p><strong>SwiftC</strong> 在前端采用了 <strong>SIL</strong> 中间语言，这是因为 <strong>Swift</strong> 作为一种高级语言，有许多特性，如 <strong>protocol</strong> 的泛型，也是一门安全的语言，确保变量在使用之前被初始化、检测不可执行的代码，于是增加了一层 <strong>SIL</strong> 来做这些事情。</p><ul><li><strong>LLVM</strong></li></ul><p><strong>LLVM</strong> 是一套编译器基础设备项目，由 <strong>C++</strong> 写成，包含一系列模块化的编译器组件和工具链，用来开发编译器的前端和后端。在 <strong>iOS</strong> 中，<strong>LLVM</strong> 作为编译器后端主要提供 <strong>Optimizer</strong> 和 <strong>Code Generator</strong> ，将接收到的 <strong>IR</strong> 中间代码进行优化，以及机器代码生成。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><pre class="mermaid">graph TD    subgraph Clang    id1(源代码) --&gt; id2(预处理)     id2(预处理) --&gt; id3(语法分析)       id3(词法分析) --  token  --&gt; id4(语法分析)    id4(语法分析) --  AST  --&gt; id5(中间代码生成)    end        subgraph Optimizer, Backend    id6(中间代码优化) --&gt; id7(BitCode生成)    id7(BitCode生成) --&gt; id8(汇编指令生成)    id8(汇编指令生成) --&gt; id9(机器码生成)    id9(机器码生成) --&gt; id11(链接生成可执行文件)    end        subgraph SwiftC    id12(源代码) --&gt; id13(解析)    id13(解析) --&gt; id14(语义分析)    id14(语义分析) --&gt; id16(Raw SIL生成)    id16(Raw SIL生成) --&gt; id17(Canonical SIL生成)    id17 --&gt; id18(SIL优化)    id18(SIL优化) --&gt; id19(中间代码生成)    end        id5 --  IR  --&gt; id6    id19 --  IR  --&gt; id6</pre><p>在前端 <strong>Objective-C</strong> 和 <strong>Swift</strong> 分别由自己的处理阶段，但最后都会生成 <strong>IR</strong> 中间代码，交由后端进行统一处理。</p><p>下面我们从一个简单的.m文件进行编译过程梳理，首先在某一个目录下创建一个 <strong>nihao.m</strong>文件</p><pre><code class="shell">touch nihao.m</code></pre><p><strong>nihao.m：</strong></p><pre><code class="objective-c">#import &lt;Foundation/Foundation.h&gt;int main(int argc, char *argv[]){    @autoreleasepool {        NSLog(@"nihao!!!");        return 0;    }}</code></pre><h3 id="Clang阶段（Objective-C-C-C-Objective-C-）"><a href="#Clang阶段（Objective-C-C-C-Objective-C-）" class="headerlink" title="Clang阶段（Objective-C / C++ / C / Objective-C++）"></a>Clang阶段（Objective-C / C++ / C / Objective-C++）</h3><h4 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h4><pre><code class="shell">xcrun clang -E helloworld.c | open -f</code></pre><pre><code># 1 "nihao.m"# 1 "&lt;built-in&gt;" 1# 1 "&lt;built-in&gt;" 3# 380 "&lt;built-in&gt;" 3# 1 "&lt;command line&gt;" 1# 1 "&lt;built-in&gt;" 2# 1 "nihao.m" 2# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h" 1 3.........int main(int argc, char *argv[]){    @autoreleasepool {        NSLog(@"nihao!!!");        return 0;    }}</code></pre><p>将预处理阶段输出到文件， 可以看到很多以 <strong>#</strong> 开头的语句，这些语句告诉我们后面跟着的内容来自哪里，这里可以看见 <strong>Foundation.h</strong> 文件的内容也包含了进来。在 <strong>Xcode</strong> 中，也可以通过 <strong>Product -&gt;  Perfrom Action -&gt; Preprocess</strong> 查看预处理阶段之后的代码。在预处理阶段做了以下这些事情：</p><ul><li>将头文件引入的其他文件加入源文件中，是一个递归的过程。</li><li>进行条件编译处理。</li><li>将宏定义直接替换，不进行语法检查。</li><li>将注释进行删除处理。</li></ul><h4 id="词法分析阶段"><a href="#词法分析阶段" class="headerlink" title="词法分析阶段"></a>词法分析阶段</h4><pre><code class="shell">xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens nihao.m</code></pre><pre><code>annot_module_include '#import &lt;Foundation/Foundation.h&gt;'        Loc=&lt;nihao.m:1:1&gt;int 'int'     [StartOfLine]    Loc=&lt;nihao.m:3:1&gt;identifier 'main'     [LeadingSpace]    Loc=&lt;nihao.m:3:5&gt;l_paren '('        Loc=&lt;nihao.m:3:9&gt;int 'int'        Loc=&lt;nihao.m:3:10&gt;identifier 'argc'     [LeadingSpace]    Loc=&lt;nihao.m:3:14&gt;comma ','        Loc=&lt;nihao.m:3:18&gt;char 'char'     [LeadingSpace]    Loc=&lt;nihao.m:3:20&gt;star '*'     [LeadingSpace]    Loc=&lt;nihao.m:3:25&gt;identifier 'argv'        Loc=&lt;nihao.m:3:26&gt;l_square '['        Loc=&lt;nihao.m:3:30&gt;r_square ']'        Loc=&lt;nihao.m:3:31&gt;r_paren ')'        Loc=&lt;nihao.m:3:32&gt;l_brace '{'     [StartOfLine]    Loc=&lt;nihao.m:4:1&gt;at '@'     [StartOfLine] [LeadingSpace]    Loc=&lt;nihao.m:5:5&gt;identifier 'autoreleasepool'        Loc=&lt;nihao.m:5:6&gt;...</code></pre><p>词法分析阶段其实是将源代码以字符文本的形式转换成 <strong>Token</strong> 流的形式，不涉及语义校验，用来标识出这个字符是标识符、括号、if语句…，最后还会标识出其所在位置，方便后续分析能够找出出错的原始位置。</p><h4 id="语法分析阶段"><a href="#语法分析阶段" class="headerlink" title="语法分析阶段"></a>语法分析阶段</h4><pre><code>xcrun clang -fsyntax-only -Xclang -ast-dump nihao.m | open -f</code></pre><pre><code>...`-FunctionDecl 0x7f9eb4bd61a0 &lt;nihao.m:3:1, line:9:1&gt; line:3:5 main 'int (int, char **)'  |-ParmVarDecl 0x7f9eb4bd5fc0 &lt;col:10, col:14&gt; col:14 argc 'int'  |-ParmVarDecl 0x7f9eb4bd6080 &lt;col:20, col:31&gt; col:26 argv 'char **':'char **'  `-CompoundStmt 0x7f9eb4bd63d0 &lt;line:4:1, line:9:1&gt;    `-ObjCAutoreleasePoolStmt 0x7f9eb4bd63b8 &lt;line:5:5, line:8:5&gt;      `-CompoundStmt 0x7f9eb4bd6398 &lt;line:5:22, line:8:5&gt;        |-CallExpr 0x7f9eb4bd6328 &lt;line:6:9, col:26&gt; 'void'        | |-ImplicitCastExpr 0x7f9eb4bd6310 &lt;col:9&gt; 'void (*)(id, ...)' &lt;FunctionToPointerDecay&gt;        | | `-DeclRefExpr 0x7f9eb4bd6250 &lt;col:9&gt; 'void (id, ...)' Function 0x7f9eb0c8d6c8 'NSLog' 'void (id, ...)'        | `-ImplicitCastExpr 0x7f9eb4bd6350 &lt;col:15, col:16&gt; 'id':'id' &lt;BitCast&gt;        |   `-ObjCStringLiteral 0x7f9eb4bd6290 &lt;col:15, col:16&gt; 'NSString *'        |     `-StringLiteral 0x7f9eb4bd6270 &lt;col:16&gt; 'char [9]' lvalue "nihao!!!"        `-ReturnStmt 0x7f9eb4bd6388 &lt;line:7:9, col:16&gt;          `-IntegerLiteral 0x7f9eb4bd6368 &lt;col:16&gt; 'int' 0</code></pre><p>语法分析阶段会输出 <strong>AST</strong>（抽象语法树），它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。通过它，可以进行语法错误分析，以及静态分析操作，涵盖内存操作和安全等方面。</p><h4 id="CodeGen阶段"><a href="#CodeGen阶段" class="headerlink" title="CodeGen阶段"></a>CodeGen阶段</h4><pre><code class="shell">xcrun clang -S -fobjc-arc -emit-llvm nihao.m -o nihao.ll</code></pre><pre><code>; ModuleID = 'nihao.m'source_filename = "nihao.m"target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx11.0.0"%struct.__NSConstantString_tag = type { i32*, i32, i8*, i64 }@__CFConstantStringClassReference = external global [0 x i32]@.str = private unnamed_addr constant [9 x i8] c"nihao!!!\00", section "__TEXT,__cstring,cstring_literals", align 1@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag { i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i64 8 }, section "__DATA,__cfstring", align 8 #0; Function Attrs: noinline optnone ssp uwtabledefine i32 @main(i32 %0, i8** %1) #1 {  %3 = alloca i32, align 4  %4 = alloca i32, align 4  %5 = alloca i8**, align 8  store i32 0, i32* %3, align 4  store i32 %0, i32* %4, align 4  store i8** %1, i8*** %5, align 8  %6 = call i8* @llvm.objc.autoreleasePoolPush() #2  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*))  store i32 0, i32* %3, align 4  call void @llvm.objc.autoreleasePoolPop(i8* %6)  %7 = load i32, i32* %3, align 4  ret i32 %7}; Function Attrs: nounwinddeclare i8* @llvm.objc.autoreleasePoolPush() #2declare void @NSLog(i8*, ...) #3; Function Attrs: nounwinddeclare void @llvm.objc.autoreleasePoolPop(i8*) #2attributes #0 = { "objc_arc_inert" }attributes #1 = { noinline optnone ssp uwtable "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }attributes #2 = { nounwind }attributes #3 = { "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }!llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6, !7}!llvm.ident = !{!8}!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 12, i32 0]}!1 = !{i32 1, !"Objective-C Version", i32 2}!2 = !{i32 1, !"Objective-C Image Info Version", i32 0}!3 = !{i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"}!4 = !{i32 1, !"Objective-C Garbage Collection", i8 0}!5 = !{i32 1, !"Objective-C Class Properties", i32 64}!6 = !{i32 1, !"wchar_size", i32 4}!7 = !{i32 7, !"PIC Level", i32 2}!8 = !{!"Apple clang version 13.0.0 (clang-1300.0.29.3)"}</code></pre><p><strong>CodeGen</strong> 阶段负责将 <strong>AST</strong> 自顶向下遍历逐步翻译成 <strong>LLVM IR</strong>，也就是编译器后端所需要的中间代码，同时 <strong>Objective-C</strong> 代码也会在这一步进行 <strong>Runtime</strong> 桥接： <strong>property</strong> 合成，<strong>ARC</strong> 处理等，如上方可以看见 <strong>autoreleasePoolPush</strong> 、 <strong>autoreleasePoolPop</strong> 操作。</p><p>至此 <strong>Clang</strong> 前端工作算是完成，接下来就交给后端进行处理。</p><h3 id="LLVM-Optimizer-阶段"><a href="#LLVM-Optimizer-阶段" class="headerlink" title="LLVM Optimizer 阶段"></a>LLVM Optimizer 阶段</h3><h4 id="IR代码优化"><a href="#IR代码优化" class="headerlink" title="IR代码优化"></a>IR代码优化</h4><pre><code class="shell">xcrun clang -Os -S -fobjc-arc -emit-llvm nihao.m -o nihao.ll</code></pre><pre><code>; ModuleID = 'nihao.m'source_filename = "nihao.m"target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"target triple = "x86_64-apple-macosx11.0.0"%struct.__NSConstantString_tag = type { i32*, i32, i8*, i64 }@__CFConstantStringClassReference = external global [0 x i32]@.str = private unnamed_addr constant [9 x i8] c"nihao!!!\00", section "__TEXT,__cstring,cstring_literals", align 1@_unnamed_cfstring_ = private global %struct.__NSConstantString_tag { i32* getelementptr inbounds ([0 x i32], [0 x i32]* @__CFConstantStringClassReference, i32 0, i32 0), i32 1992, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i64 8 }, section "__DATA,__cfstring", align 8 #0; Function Attrs: optsize ssp uwtabledefine i32 @main(i32 %0, i8** nocapture readnone %1) local_unnamed_addr #1 {  %3 = tail call i8* @llvm.objc.autoreleasePoolPush() #2  notail call void (i8*, ...) @NSLog(i8* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to i8*)) #4, !clang.arc.no_objc_arc_exceptions !9  tail call void @llvm.objc.autoreleasePoolPop(i8* %3) #2  ret i32 0}; Function Attrs: nounwinddeclare i8* @llvm.objc.autoreleasePoolPush() #2; Function Attrs: optsizedeclare void @NSLog(i8*, ...) local_unnamed_addr #3; Function Attrs: nounwinddeclare void @llvm.objc.autoreleasePoolPop(i8*) #2attributes #0 = { "objc_arc_inert" }attributes #1 = { optsize ssp uwtable "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }attributes #2 = { nounwind }attributes #3 = { optsize "darwin-stkchk-strong-link" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="___chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "tune-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }attributes #4 = { optsize }!llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6, !7}!llvm.ident = !{!8}!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 12, i32 0]}!1 = !{i32 1, !"Objective-C Version", i32 2}!2 = !{i32 1, !"Objective-C Image Info Version", i32 0}!3 = !{i32 1, !"Objective-C Image Info Section", !"__DATA,__objc_imageinfo,regular,no_dead_strip"}!4 = !{i32 1, !"Objective-C Garbage Collection", i8 0}!5 = !{i32 1, !"Objective-C Class Properties", i32 64}!6 = !{i32 1, !"wchar_size", i32 4}!7 = !{i32 7, !"PIC Level", i32 2}!8 = !{!"Apple clang version 13.0.0 (clang-1300.0.29.3)"}!9 = !{}</code></pre><p><strong>IR</strong> 代码优化会调用相应 <strong>Pass</strong> 进行处理，<strong>Pass</strong> 由多个节点组成，都是 <strong>Pass</strong> 类的子类，每个节点负责特定的优化。这使得我们能够自主的控制优化的强度，在<strong>Build Strrings -&gt; Optimization Level</strong> 中可指定优化程度，一些常见的代码优化方法如下：</p><ul><li>删除公共子表达式</li><li>删除无用代码</li><li>常量合并</li><li>代码移动</li><li>删除归纳变量</li></ul><h4 id="生成-BitCode（Archive时）"><a href="#生成-BitCode（Archive时）" class="headerlink" title="生成 BitCode（Archive时）"></a>生成 BitCode（Archive时）</h4><pre><code class="shell">xrun clang -emit-llvm -c nihao.m -o nihao.bc</code></pre><pre><code>dec0 170b 0000 0000 1400 0000 0010 00000700 0001 4243 c0de 3514 0000 0700 0000620c 3024 9596 a6a5 f7d7 7f7d d3b4 4ffb76ef df3f 2d44 0132 0500 0000 210c 00004903 0000 0b02 2100 0200 0000 1600 00000781 2391 41c8 0449 0610 3239 9201 840c2505 0819 1e04 8b62 8014 4502 4292 0b42a410 3214 3808 184b 0a32 5288 4870 c421...</code></pre><p><strong>BitCode</strong> 是 <strong>LLVM</strong> 引入的另一种中间代码，虽然看起来比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。</p><p>但只会在 <strong>Archive</strong> 时，<strong>BitCode</strong> 才会被嵌入到链接后的二进制文件，用于提交给 <strong>App Store</strong>，包含 <strong>Bitcode</strong> 配置的程序将会在 <strong>App Store</strong> 上被重新编译和链接，进而对可执行文件做优化。值得注意的是，优化这一步是在 <strong>App Store</strong> 中做的处理，本地没有做处理。进行其他类型的 <strong>Build</strong> (非 <strong>Archive</strong> )时，编译器只会检查是否满足开启 <strong>BitCode</strong> 的条件，但并不会真正生成 <strong>BitCode</strong> 。</p><h3 id="LLVM-Code-Generator阶段"><a href="#LLVM-Code-Generator阶段" class="headerlink" title="LLVM Code Generator阶段"></a>LLVM Code Generator阶段</h3><h4 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h4><pre><code class="shell">xcrun clang -S -fobjc-arc nihao.m -o nihao.s</code></pre><pre><code>    .section    __TEXT,__text,regular,pure_instructions    .build_version macos, 11, 0    sdk_version 12, 0    .globl    _main                           ## -- Begin function main    .p2align    4, 0x90_main:                                  ## @main    .cfi_startproc## %bb.0:    pushq    %rbp    .cfi_def_cfa_offset 16    .cfi_offset %rbp, -16    movq    %rsp, %rbp    .cfi_def_cfa_register %rbp    subq    $32, %rsp    movl    $0, -4(%rbp)    movl    %edi, -8(%rbp)    movq    %rsi, -16(%rbp)    callq    _objc_autoreleasePoolPush    movq    %rax, -24(%rbp)                 ## 8-byte Spill    leaq    L__unnamed_cfstring_(%rip), %rdi    movb    $0, %al    callq    _NSLog    movq    -24(%rbp), %rdi                 ## 8-byte Reload    movl    $0, -4(%rbp)    callq    _objc_autoreleasePoolPop    movl    -4(%rbp), %eax    addq    $32, %rsp    popq    %rbp    retq    .cfi_endproc                                        ## -- End function    .section    __TEXT,__cstring,cstring_literalsL_.str:                                 ## @.str    .asciz    "nihao!!!"    .section    __DATA,__cfstring    .p2align    3                               ## @_unnamed_cfstring_L__unnamed_cfstring_:    .quad    ___CFConstantStringClassReference    .long    1992                            ## 0x7c8    .space    4    .quad    L_.str    .quad    8                               ## 0x8    .section    __DATA,__objc_imageinfo,regular,no_dead_stripL_OBJC_IMAGE_INFO:    .long    0    .long    64.subsections_via_symbols</code></pre><p>汇编语言更加接近机器语言，能够直接对硬件进行操作，生成的程序与其他的语言相比具有更高的运行速度，占用更小的内存。</p><p>目前所有 <strong>iOS</strong> 设备都采用 <strong>ARM</strong> 处理器，这意味着都是采用 <strong>ARM</strong> 指令集，如 <strong>armv6 / armv7 / armv7s / arm64</strong>，这些指令集都是向下兼容的。</p><p>每种 <strong>CPU</strong> 架构都有着相应的指令集，可以针对不同的架构产生不同的汇编指令，加上上面 <strong>- arch arch_type</strong> 选项即可，更多请参见<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html">官网</a>。在 <strong>Xcode</strong> 中可在 <strong>Build Settings -&gt; Architectrues</strong> 指定产生的 <strong>CPU</strong> 指令集。</p><h4 id="生成机器代码"><a href="#生成机器代码" class="headerlink" title="生成机器代码"></a>生成机器代码</h4><pre><code class="shell">xcrun clang -fmodules -c nihao.s -o nihao.o</code></pre><p>可以发现机器码二进制文件无法阅读，可借助 <strong>otool</strong> 或者 <strong>MachOView</strong> 等工具查看文件中的相关内容：</p><pre><code class="shell">otool -v -h nihao.o</code></pre><pre><code>nihao.o:Mach header      magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flagsMH_MAGIC_64   X86_64        ALL  0x00      OBJECT     4        680 SUBSECTIONS_VIA_SYMBOLS</code></pre><p>可以看见 <strong>.o</strong> 文件实际上是 <strong>mach-o</strong> 格式，这里我们输入可执行文件的头部，规定了这个文件是什么，适应架构的相关信息，以及文件是如何被加载的。更多关于 <strong>mach-o</strong> 的知识<a href="https://www.jianshu.com/p/54d842db3f69">参见</a>。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><pre><code class="shell">xcrun clang nihao.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</code></pre><pre><code class="shell">./a.out</code></pre><pre><code>2021-11-03 16:06:41.734 a.out[6394:220026] nihao!!!</code></pre><p>由于我们引入了 <strong>Foundation</strong> 里面的文件，所以需要将目标文件和 <strong>Foundation framework</strong>进行链接，接着就可以运行我们的程序了。</p><p>这里涉及到一个概念：符号表，里面存储的元素如下：</p><pre><code class="xml">&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</code></pre><p>这里我们输入a.out的符号信息</p><pre><code>nm -nm a.out</code></pre><pre><code>                 (undefined) external _NSLog (from Foundation)                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)                 (undefined) external _objc_autoreleasePoolPop (from libobjc)                 (undefined) external _objc_autoreleasePoolPush (from libobjc)                 (undefined) external dyld_stub_binder (from libSystem)0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header0000000100003f20 (__TEXT,__text) external _main0000000100008018 (__DATA,__data) non-external __dyld_private</code></pre><p>对于动态链接库的符号（如 <strong>Foundation</strong>），最终会记录下这个符号是通过进行链接的，并记录下依赖于哪个动态链接库。在运行时，动态链接器（<strong>dyld</strong>）会去解析这些 <strong>undefined</strong> 符号。对于其他位置的符号，会直接修正这些符号的具体位置信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了关于 iOS 编译器、iOS 编译过程的基础知识。学习了这些，对 iOS 编译有个整体认识。就本人而言，在一路搜寻资料的过程中，对之前一些零散的知识点有了一些更加深入的认识。由于篇幅有限，关于 SwiftC 的编译过程没有多做介绍，后面会再出一篇进行介绍。</p><p>🔗：</p><p><a href="https://objccn.io/issue-6-3/">ObjC 中国 - Mach-O 可执行文件</a></p><p><a href="https://kiprey.github.io/2020/06/LLVM-IR-pass/">代码优化与LLVM IR pass</a></p><p><a href="http://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/">关于bitcode, 知道这些就够了</a></p><p><a href="https://zhuanlan.zhihu.com/p/340782811">iOS 编译链接：Objective-C 编译链接</a></p><p><a href="https://www.jianshu.com/p/54d842db3f69">趣探 Mach-O：文件格式分析</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Compile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSTimer循环引用分析与解决</title>
      <link href="/2021/09/29/2021-09-29-NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/09/29/2021-09-29-NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文将从如何使用 <strong>NSTimer</strong> 、 <strong>NSTimer</strong> 何种情况下会造成循环引用，以及如何避免循环引用几个角度进行介绍。</p><span id="more"></span><h3 id="NSTimer-如何使用"><a href="#NSTimer-如何使用" class="headerlink" title="NSTimer 如何使用"></a>NSTimer 如何使用</h3><blockquote><p>A timer that fires after a certain time interval has elapsed, sending a specified message to a target object.</p><p>翻译：一种计时器，在经过一定的时间间隔后触发，向目标对象发送指定的消息。</p></blockquote><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><strong>NSTimer</strong> 提供了三种创建方式：</p><ol><li><p>以 <code>scheduledTimerWithTimeInterval</code> 类方法开头的创建实例</p></li><li><p>以 <code>timerWithTimeInterval</code> 开头的创建实例</p></li><li><p>以 <code>init</code> 方法初始化方法创建实例</p></li></ol><p>若采用第一种方式创建，会以 <strong>default mode</strong> 方式自动加入到当前的 <strong>RunLoop</strong> 中。</p><p>若采用第二、三种方式创建，需手动调用NSRunLoop对象的 <code>addTimer:forMode:</code> 方法。</p><pre><code class="swift">let timer = Timer.init(timeInterval: 1.0, repeats: true) { timer in   print("This")}RunLoop.main.add(timer, forMode: .default)</code></pre><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p><code>invalidate()</code> </p><p>该方法是在其加入的 <strong>RunLoop</strong> 对象中移除timer的唯一方法，同时会 <strong>RunLoop</strong> 对象会移除其对对象的强引用，若配置了 <strong>target</strong> 和 <strong>user info</strong> 对象， <strong>timer</strong> 也会移除对这些对象的强引用。</p><h3 id="为何会造成循环引用"><a href="#为何会造成循环引用" class="headerlink" title="为何会造成循环引用"></a>为何会造成循环引用</h3><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>考虑一个常见使用 <strong>NSTimer</strong> 的场景：在 <strong>ViewController</strong> 中将 <strong>timer</strong> 作为属性，而 <strong>timer</strong> 在创建采用了 <strong>target-action</strong> 的方式，根据 <strong>Apple</strong> 文档，<strong>timer</strong> 会对 <strong>target</strong> 产生强引用，这就产生了有向环，导致循环引用，下图是上例对象引用图：</p><img src="/images/blog/image-20210817112104936.png" alt="image-20210817112104936" style="zoom:40%;"><h4 id="RunLoop持有timer"><a href="#RunLoop持有timer" class="headerlink" title="RunLoop持有timer"></a>RunLoop持有timer</h4><p>还是上例的场景，若在 <strong>timer</strong> 创建时不采用 <strong>target-action</strong> ，是不是就可以解决了？</p><p>确实可以解决，但还存在一个问题，由于 <strong>RunLoop</strong> 对象还持有着 <strong>timer</strong> 对象，这时 <strong>ViewController</strong> 能被正常释放，但 <strong>timer</strong> 的引用计数由于不为 <strong>1</strong> ，无法被释放，这种情况只是 <strong>timer</strong> 无法被释放，并不算循环引用范畴，当然若 <strong>RunLoop</strong> 对象被释放了，则这个 <strong>timer</strong> 也会被释放掉。</p><img src="/images/blog/image-20210817145841853.png" alt="image-20210817145841853" style="zoom:40%;"><p>当然此上两种情况都是将 <strong>timer</strong> 的 <code>repeat</code> 参数设置为 <code>true</code> 时，若为 <code>false</code> 则在定时器第一次触发后，会自动失效，即 <strong>RunLoop</strong> 会移除对 <strong>timer</strong> 的强引用， <strong>timer</strong> 也会移除对 <strong>target</strong> 和 <strong>user info</strong> 对象的强引用。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="合适的时机调用-invalidate"><a href="#合适的时机调用-invalidate" class="headerlink" title="合适的时机调用 invalidate()"></a>合适的时机调用 <code>invalidate()</code></h4><p>在上文介绍了<code>invalidate()</code> ， 我们只需要在合适的时机调用 <code>invalidate()</code>即可。</p><p>那么什么是合适的时机呢？</p><ol><li>若清楚知道什么时候 <strong>timer</strong> 不再使用，则应立即调用。</li><li>若不清楚则应破除循环引用，最后在 <strong>ViewController</strong> 的 <code>deinit</code> 中进行调用。</li></ol><h4 id="针对循环引用，需破除有向环"><a href="#针对循环引用，需破除有向环" class="headerlink" title="针对循环引用，需破除有向环"></a>针对循环引用，需破除有向环</h4><ol><li>采用 <code>weak</code> 关键字修饰 <strong>timer</strong> ，但需采用<code>scheduledTimerWithTimeInterval</code> 类方法开头的创建实例，因为这个方法会将 <strong>timer</strong> 加入到 <strong>RunLoop</strong> 对象中，否则由于 <code>weak</code> 修饰， <strong>timer</strong> 会被自动设为<code>nil</code>。</li><li>采用 <code>weak</code> 关键字修饰 <strong>target</strong> 对象，但需在 <strong>block</strong> 中进行使用，原理大概是 <strong>block</strong> 中的 <strong>weakSelf</strong> 相当于一个临时变量，进而阻止了循环引用。</li><li>采用中介者模式，让其他对象承担 <code>target</code> 角色，从而阻止循环引用。</li><li>基于 <strong>NSProxy</strong> 方式，与 <strong>3</strong> 类似，通过其他对象来阻止循环引用，需注意的是 <strong>NSProxy</strong> 无法直接使用。</li><li>也可直接使用 <strong>Apple</strong> 提供的新 <strong>API</strong>：</li></ol><pre><code class="swift">class func scheduledTimer(withTimeInterval interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -&gt; Void) -&gt; Timerinit(timeInterval interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -&gt; Void)convenience init(fire date: Date, interval: TimeInterval, repeats: Bool, block: @escaping (Timer) -&gt; Void)</code></pre><blockquote><p>the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references。</p><p>翻译：在执行时，定时器本身作为参数传递给这个块，以帮助避免循环引用。</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://juejin.cn/post/6844903968250789896#heading-5">iOS之NSTimer循环引用的解决方案</a></p><p><a href="https://www.jianshu.com/p/e8fc6c2b3afa">iOS中Timer循环引用原因及解决方案</a></p><p><a href="https://developer.apple.com/documentation/foundation/nstimer/">Apple文档 - NSTimer</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSTimer </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不以功利为目的</title>
      <link href="/2021/08/29/2021-11-9-%E4%B8%8D%E4%BB%A5%E5%8A%9F%E5%88%A9%E4%B8%BA%E7%9B%AE%E7%9A%84/"/>
      <url>/2021/08/29/2021-11-9-%E4%B8%8D%E4%BB%A5%E5%8A%9F%E5%88%A9%E4%B8%BA%E7%9B%AE%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>今天突然心血来潮想写点什么，本来看着《计算机网络 - 自顶向下方法》。突然觉得我为什么要看本书，这就让我不断的反问，不断的刨根，我是为了面试、为了系统的学习、为了向其他人展示什么…，最终我想到了，我在买这本书的时候，我仅是为了给大学的自己补一下遗憾，没有读几本经典的书，没有去系统的学习一些知识，没有探索计算机那令人叹为观止的地方。回想大学时代，自己从没想过会去完完整整的读一本书。就如“重构”一般，知道它重要，但从未有“恰当”的时间进行下去，抑或是针对其中重要的部分，进行“熟读与背诵”，抑或是直接拿队友的重点笔记进行查阅，但我从没完整的读过一本书。</p><p>我在想为什么会这样，我认识到我读书是为什么，是为了考一个好高中、考一个好大学、找一份好工作，还是能够领略一番书中的绮丽瑰宝，可能也只是无聊打发时间罢了。但我想，不应以功利的心态去读书了，那样太累、又太机械，我总想立即从书中获取什么，仿佛有价值千金的宝藏般，让我马上超越其他人。可事实哪有那么容易，每一个人不都是日积月累，有量变引起质变才获得成功的吗。</p><p>毕业以来大概5个月了，我常常在想，我今后会成为怎样的人，我如何才能像其他人一样优秀，可以侃侃而谈，可以谈笑风生。但我想先成为那个一直都想成为的人，做好自己、不断努力、那个随性但又坚定的那个人。我想说很多话，但总觉得人微言轻，所以在我没法掂量轻重时，还是少一些言语，多一分实干。</p><p>最后，从高考作文之后，边再也没有能够抒发情感或是记录生活的地方了，给自己立一个目标，能够以半年或者每个季度或者每个月都能够写一些东西总结下自己的生活，下一步该怎么走，自己有哪些不足。</p><p>最后的最后，不以功利为目的，我想去多看、多想。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
