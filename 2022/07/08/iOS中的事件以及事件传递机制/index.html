<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/Common/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/Common/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/images/Common/apple-touch-icon.png?v=2.6.2" sizes="180x180"><link rel="mask-icon" href="/images/Common/safari-pinned-tab.svg?v=2.6.2" color="#54bcff"><meta name="google-site-verification" content="hFc7D0nhWN4O0yFHqNZJV2kd6x4RmgWcI2eqeLKXUu8"><meta name="msvalidate.01" content="BF78360243509ECB201D8CD5740AB913"><meta name="baidu-site-verification" content="code-De3JgoMLjj"><meta name="description" content="前言       iOS 中有 8 种事件，本文重点介绍触摸事件的传递机制与响应流程。可以带着一下问题进行阅读：  iOS 中有哪些事件类型，谁来进行事件的响应，怎么来响应呢？  触摸事件的传递与响应流程  hitTest 方法的作用，它有什么实践场景？  UIControl 与 UIGestureRecognizer 也能响应触摸事件，UIResponder 的响应方式有什">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中的事件以及事件传递机制">
<meta property="og:url" content="https://xuhaodong1.github.io/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="nihao&#39; Blog">
<meta property="og:description" content="前言       iOS 中有 8 种事件，本文重点介绍触摸事件的传递机制与响应流程。可以带着一下问题进行阅读：  iOS 中有哪些事件类型，谁来进行事件的响应，怎么来响应呢？  触摸事件的传递与响应流程  hitTest 方法的作用，它有什么实践场景？  UIControl 与 UIGestureRecognizer 也能响应触摸事件，UIResponder 的响应方式有什">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xuhaodong1.github.io/images/blog/responderChain.png">
<meta property="og:image" content="https://xuhaodong1.github.io/images/blog/image-20220620215940554.png">
<meta property="og:image" content="https://xuhaodong1.github.io/images/blog/image-20220704022615988.png">
<meta property="og:image" content="https://xuhaodong1.github.io/images/blog/image-20220707113956921.png">
<meta property="og:image" content="https://xuhaodong1.github.io/images/blog/image-20220707114606464.png">
<meta property="article:published_time" content="2022-07-08T09:49:00.000Z">
<meta property="article:modified_time" content="2022-07-08T10:54:20.927Z">
<meta property="article:author" content="nihao">
<meta property="article:tag" content="UI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xuhaodong1.github.io/images/blog/responderChain.png"><title>iOS中的事件以及事件传递机制 | nihao' Blog</title><link ref="canonical" href="https://xuhaodong1.github.io/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: {"switchPost":true},
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">iOS中的事件以及事件传递机制</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon" data-popover="发表时间" data-popover-pos="up"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__value">2022-07-08</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon" data-popover="字数统计" data-popover-pos="up"><i class="far fa-file-word"></i></span><span class="post-meta-item__value">3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon" data-popover="阅读时间" data-popover-pos="up"><i class="far fa-clock"></i></span><span class="post-meta-item__value">32分</span></span></div></header><div class="post-body">
        <h2 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h2>
      <p>iOS 中有 8 种事件，本文重点介绍触摸事件的传递机制与响应流程。可以带着一下问题进行阅读：</p>
<ul>
<li><p>iOS 中有哪些事件类型，谁来进行事件的响应，怎么来响应呢？</p>
</li>
<li><p>触摸事件的传递与响应流程</p>
</li>
<li><p><code>hitTest</code> 方法的作用，它有什么实践场景？</p>
</li>
<li><p><code>UIControl</code> 与 <code>UIGestureRecognizer</code> 也能响应触摸事件，<code>UIResponder</code> 的响应方式有什么不同？</p>
<span id="more"></span>

        <h2 id="响应者-amp-响应者链"   >
          <a href="#响应者-amp-响应者链" class="heading-link"><i class="fas fa-link"></i></a><a href="#响应者-amp-响应者链" class="headerlink" title="响应者 &amp; 响应者链"></a>响应者 &amp; 响应者链</h2>
      </li>
<li><p>响应者即 <code>UIResponder class</code> 的一个实例；</p>
</li>
<li><p>响应者链为响应者组成的一个链式结构，不同的链式结构组合起来看起来像一个倒过来的树形结构。</p>
</li>
<li><p><code>UIResponder</code> 中包含了许多处理事件的方法，如果我们想在这个对象里响应事件，那么重写这个方法即可。</p>
</li>
</ul>
<img src="/images/blog/responderChain.png" alt="A flow diagram: On the left, a sample app contains a label (UILabel), a text field for the user to input text (UITextField), and a button (UIButton) to  press after entering text in the field. On the right, the flow diagram shows how, after the user pressed the button, the event moves through the responder chain—from UIView, to UIViewController, to UIWindow, UIApplication, and finally to UIApplicationDelegate." style="zoom:67%;" />

<ul>
<li><strong>UIView</strong>：如果 <code>view</code> 是 <code>UIViewController</code> 的 <code>root view</code>，下一个响应者为 <code>UIViewController</code>，否则下一个响应者为<code>superview</code>。</li>
<li><strong>UIViewController</strong>：如果 <code>UIViewController</code> 的 <code>view</code> 是 <code>UIWindow</code> 的 <code>root view</code> 下一个响应者对象是 <code>window</code>；如果 当前 <code>UIViewController</code> 由另一个 <code>UIViewController push</code> 或者 <code>presented</code>，则下一个响应者为 弹出该 <code>vc</code> 的 <code>UIViewController</code>，例如 <code>UINavigationController</code>、<code>UITableBarController</code>。</li>
<li><strong>UIWindow</strong>：下一个响应者为 <code>UIApplication</code></li>
<li><strong>UIApplication</strong>：下一个响应者为 <code>UIApplicationDelegate</code>，前提是它不是 <code>UIView</code>、<code>UIViewController</code>、以及不是 <code>UIApplication</code> 本身。一般来说，是指 <code>AppDelegate</code>。</li>
</ul>

        <h2 id="事件-amp-谁是事件的第一响应者"   >
          <a href="#事件-amp-谁是事件的第一响应者" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件-amp-谁是事件的第一响应者" class="headerlink" title="事件 &amp; 谁是事件的第一响应者"></a>事件 &amp; 谁是事件的第一响应者</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>事件类型</th>
<th>第一响应者</th>
</tr>
</thead>
<tbody><tr>
<td>触摸事件 touch events</td>
<td>发生触摸的视图</td>
</tr>
<tr>
<td>按压事件 press events</td>
<td>被聚焦的对象</td>
</tr>
<tr>
<td>摇动事件 shake-motion events</td>
<td>你(or UIKit)指定的对象</td>
</tr>
<tr>
<td>远程控制事件 remote-control event</td>
<td>你(or UIKit)指定的对象</td>
</tr>
<tr>
<td>编辑菜单消息 editing menu messages</td>
<td>你(or UIKit)指定的对象</td>
</tr>
<tr>
<td>加速器 accelerometers</td>
<td>委任的对象</td>
</tr>
<tr>
<td>陀螺 gyroscopes</td>
<td>委任的对象</td>
</tr>
<tr>
<td>磁力仪 magnetometer</td>
<td>委任的对象</td>
</tr>
</tbody></table></div>
<p>在 iOS 中，有 8 种类型的事件，响应这些事件的对象被称为响应者，系统的一些常见的响应者为 <code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>、<code>UIAppllication</code>、<code>AppDelegate</code>，在找到最佳响应者后，如果事件没有被处理，事件会随着响应者链进行传递。不过有些事件在进行传递的时候，即使重写了响应事件的方法，特定对象不会进行响应，例如 <code>shake-motion events</code> 不会由 <code>UIView</code>、<code>UIApplication</code>、<code>AppDelegate</code> 进行响应。</p>
<ul>
<li>触摸事件 <code>touch events</code>，是 iOS 中最常见的事件，每一次触碰都会由 IOKit 通过 IPC 交给 SpringBoard，进而通过 <code>mach port</code> 传递给合适的进程进行响应，第一响应者是发生触碰的视图，后面会重点讲解。</li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">touchesBegan</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">touchesMoved</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">touchesEnded</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">touchesCancelled</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">9.1</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">touchesEstimatedPropertiesUpdated</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;)</span><br></pre></td></tr></table></div></figure>

<ul>
<li>按压事件<code>press events</code>，表示如遥控器或者游戏手柄中进行按压触碰而产生的事件，由当前聚焦的对象进行响应。</li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">9.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">pressesBegan</span>(<span class="keyword">_</span> <span class="params">presses</span>: <span class="type">Set</span>&lt;<span class="type">UIPress</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIPressesEvent</span>?)</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">9.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">pressesChanged</span>(<span class="keyword">_</span> <span class="params">presses</span>: <span class="type">Set</span>&lt;<span class="type">UIPress</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIPressesEvent</span>?)</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">9.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">pressesEnded</span>(<span class="keyword">_</span> <span class="params">presses</span>: <span class="type">Set</span>&lt;<span class="type">UIPress</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIPressesEvent</span>?)</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">9.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">pressesCancelled</span>(<span class="keyword">_</span> <span class="params">presses</span>: <span class="type">Set</span>&lt;<span class="type">UIPress</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIPressesEvent</span>?)</span><br></pre></td></tr></table></div></figure>

<ul>
<li>摇动事件 <code>shake-motion events</code>，晃动设备进行触发。</li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">motionBegan</span>(<span class="keyword">_</span> <span class="params">motion</span>: <span class="type">UIEvent</span>.<span class="type">EventSubtype</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">motionEnded</span>(<span class="keyword">_</span> <span class="params">motion</span>: <span class="type">UIEvent</span>.<span class="type">EventSubtype</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) </span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">motionCancelled</span>(<span class="keyword">_</span> <span class="params">motion</span>: <span class="type">UIEvent</span>.<span class="type">EventSubtype</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br></pre></td></tr></table></div></figure>

<ul>
<li>远程控制事件 <code>remote-control event</code>，在音视频播放时，锁屏界面或者控制中心中点击 “上一个”、“下一个”、“暂停”和“继续”等操作时触发的事件。</li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">4.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">remoteControlReceived</span>(<span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?)</span><br></pre></td></tr></table></div></figure>

<ul>
<li>编辑菜单消息 <code>editing menu messages</code>，编辑文本出现的菜单列表产生的事件。</li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">buildMenu</span>(<span class="params">with</span> <span class="params">builder</span>: <span class="type">UIMenuBuilder</span>)</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">validate</span>(<span class="keyword">_</span> <span class="params">command</span>: <span class="type">UICommand</span>)</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">3.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> undoManager: <span class="type">UndoManager</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> editingInteractionConfiguration: <span class="type">UIEditingInteractionConfiguration</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>加速器事件、陀螺事件、磁力仪事件不跟随响应者链，<code>Core Motion</code> 将这些事件直接传递给指定的委任对象。</li>
</ul>

        <h2 id="触摸事件流程"   >
          <a href="#触摸事件流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#触摸事件流程" class="headerlink" title="触摸事件流程"></a>触摸事件流程</h2>
      <img src="/images/blog/image-20220620215940554.png" alt="image-20220620215940554" style="zoom:80%;" />

<p>当触摸事件发生时，被用户面板即硬件由电信号采集到，之后再传递给 <code>IOKit.framework</code>，并将事件封装为 <code>IOHIDEvent</code>；之后通过 IPC 转发给 SpringBoard 进程；再由 SpringBoard 进程再次通过 IPC 将事件传递给合适的 APP 进程；由主线程 RunLoop 进行处理，先触发 <code>source1</code> 回调，后触发了 <code>source0</code> 回调，并将事件封装为 <code>UIEvent</code>；然后将事件加入 <code>UIApplication</code> 对象的事件队列中，出队后，开始寻找最佳响应者 <code>hit-Testing</code>，找到最佳响应者后。由 <code>UIApplication</code> 对象 从 <code>sendEvent</code> 方法将事件传递给 <code>window</code> 对象，再由 <code>window</code> 对象 <code>sendEvent</code> 到最佳响应者，随后进行事件响应以及传递。寻找最佳响应者以及事件响应后面会重点提及，这里先简单对 IOKit.framework、SpringBoard 以及 IPC 进行介绍：</p>
<ul>
<li>IOKit.framework：</li>
<li>SpringBoard：</li>
<li>IPC：</li>
</ul>

        <h3 id="寻找最佳响应者"   >
          <a href="#寻找最佳响应者" class="heading-link"><i class="fas fa-link"></i></a><a href="#寻找最佳响应者" class="headerlink" title="寻找最佳响应者"></a>寻找最佳响应者</h3>
      <ol>
<li>由 <code>UIApplication</code> 传递给 <code>UIWindow</code>，如果有多个 <code>UIWindow</code> 对象，则按倒序进行查询。</li>
<li>对于每一个 <code>UIWindow</code>、<code>UIView</code> 对象来说，也是倒叙查询其子视图和本视图能否响应。</li>
</ol>
<p>如果从遍历方式来看，是一个反过来的 <code>dfs</code>。倒叙是因为如果有视图重叠，在上方的是后加入的对象；具体来说都是通过 <code>UIView</code> 的 <code>hitTest</code> 方法进行判断是不是最佳响应者，如果存在则返回该 <code>UIView</code>，不存在则返回 <code>nil</code>。</p>
<ul>
<li><code>hitTest(_ point: CGPoint, with event: UIEvent?)</code> <strong>模拟代码</strong></li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">hitTest</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.isUserInteractionEnabled <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="keyword">self</span>.isHidden <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.alpha <span class="operator">&gt;</span> <span class="number">0.01</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.point(inside: point, with: event) &#123;</span><br><span class="line">        <span class="keyword">for</span> subview <span class="keyword">in</span> subviews.reversed() &#123;</span><br><span class="line">            <span class="keyword">let</span> convertedPoint <span class="operator">=</span> subview.convert(point, from: <span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">let</span> hitTestView <span class="operator">=</span> subview.hitTest(convertedPoint, with: event)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> hitTestView <span class="operator">=</span> hitTestView &#123;</span><br><span class="line">                <span class="keyword">return</span> hitTestView</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li><p>需要 <code>isUserInteractionEnabled</code> 为 <code>true</code>、<code>isHidden</code> 为 <code>fasle</code> 且透明度 &gt; 0.01</p>
</li>
<li><p>如果命中点在视图内，尝试倒序遍历子视图，查找是否有更合适的点，若有则返回子视图的 <code>hitTest()</code>，若无则返回本视图(<code>self</code>)。</p>
</li>
<li><p>如果命中点不在视图内，则返回 <code>nil</code>。</p>
</li>
</ol>
<ul>
<li><code>point(inside point: CGPoint, with event: UIEvent?)</code> <strong>模拟代码</strong></li>
</ul>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">point</span>(<span class="params">inside</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bounds.contains(point)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li>判断当前 bounds 是否包含该点。</li>
</ol>

        <h3 id="触摸事件的响应以及传递"   >
          <a href="#触摸事件的响应以及传递" class="heading-link"><i class="fas fa-link"></i></a><a href="#触摸事件的响应以及传递" class="headerlink" title="触摸事件的响应以及传递"></a>触摸事件的响应以及传递</h3>
      <p>找到最佳响应者后，<code>UIApplication</code> 对象 <code>sendEvent</code> 到响应该视图的 <code>UIWindow</code>，再有 <code>UIWindow</code> 对象 <code>sendEvent</code> 到最佳响应者，这一点可以通过查看调用栈帧看出：</p>
<img src="/images/blog/image-20220704022615988.png" alt="image-20220704022615988" style="zoom:100%;" />

<p>传递给最佳响应者后，便可以进行事件的响应了，对于触摸事件来说，调用上述提到的 5 个方法即代表响应。事件的拦截是通过 <code>open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</code> 实现的，传递方式与规则见上文中 <strong>响应者 &amp; 响应者链</strong>：</p>
<ul>
<li>不重写，默认将事件交给响应者链传递</li>
<li>重写不掉用 <code>super.touchesBegan(touches, with: event)</code>，事件由该响应者处理，不进行传递</li>
<li>重写并调用 <code>super.touchesBegan(touches, with: event)</code>，将事件交给响应者链传递</li>
</ul>
<p>采用 <code>touchesBegan</code> 等系列方法以响应算是比较底层的方式，为快速响应各种类型的触摸事件，Apple 提供了 <code>UIGestureRecognizer</code> 与 <code>UIControl</code> 这两种方式。</p>

        <h4 id="UIGestureRecognizer"   >
          <a href="#UIGestureRecognizer" class="heading-link"><i class="fas fa-link"></i></a><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h4>
      <p>UIGestureRecognizer 手势识别器是处理视图中的触摸和按压事件的最好方式，如果我们仅用触摸事件基本响应方式进行处理的话，难度较大且不现实。它是一个基类，Apple 提供了 8 种手势，同时也可以创建自定义手势。</p>
<ul>
<li><code>UITapGestureRecognizer</code>：轻点手势</li>
<li><code>UIPinchGestureRecognizer</code>：捏合手势</li>
<li><code>UIRotationGestureRecognizer</code>：旋转手势</li>
<li><code>UISwipeGestureRecognizer</code>：滑动手势</li>
<li><code>UIPanGestureRecognizer</code>：拖拽手势</li>
<li><code>UIScreenEdgePanGestureRecognizer</code>：屏幕边缘拖拽手势</li>
<li><code>UILongPressGestureRecognizer</code>：长按手势</li>
<li><code>UIHoverGestureRecognizer</code>：指针悬停（macOS &amp; iPadOS）</li>
</ul>
<p>手势识别器分为离散型和持续性两种：</p>
<p>离散型手势在识别到手势后只调用一次 <code>action</code> 方法，其变化过程为：</p>
<ul>
<li><p>识别成功：Possible —&gt; Recognized</p>
</li>
<li><p>识别失败：Possible —&gt; Failed</p>
</li>
</ul>
<p>持续性手势在满足最初始识别条件后，会在手势信息变化中多次调用 action 方法，其变化过程为：</p>
<ul>
<li><p>完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Ended</p>
</li>
<li><p>不完整识别：Possible —&gt; Began —&gt; [Changed] —&gt; Cancel</p>
</li>
</ul>
<p><strong>对于 UIResponder 的触摸响应优先级来说，UIGestureRecognizer 的响应优先级会更高一点</strong>；在 hit-Testing 过程中，就会判断当前 <code>view</code> 的手势识别器是否符合条件，符合条件的手势识别器对象会保存在 <code>UIEvent</code> 中，并在 <code>sendEvent</code> 时首先发送给它，如果手势识别器识别成功，则默认会取消剩余的触摸响应事件，表现为调用 <code>touchesCancelled</code> 方法。</p>
<p>三个重要的属性会改变上述过程：</p>
<ul>
<li><code>cancelsTouchesInView</code>：默认为 true，表示在识别手势成功后，是否取消剩余的触摸响应事件；</li>
<li><code>delaysTouchesBegan</code>：默认为 false，表示是否在识别手势失败后，才将触摸事件传递给 <code>hit-Tested view</code>；</li>
<li><code>delaysTouchesEnded</code>：默认为 true，表示是否在识别手势失败后，才将 <code>touchesEnded</code> 事件发送给 <code>hit-Tested view</code>；</li>
</ul>
<p>手势冲突</p>
<p>手势默认是互斥的，但可以利用 <code>UIGestureRecognizerDelegate</code> 进行手势优先级处理。</p>

        <h4 id="UIControl"   >
          <a href="#UIControl" class="heading-link"><i class="fas fa-link"></i></a><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h4>
      <p>UIControl 是响应特定动作或意图的视觉元素的控件基类，它是 <code>UIView</code> 的子类，因此它也是响应者对象；<code>UIButton</code>、<code>UISwitch</code>、<code>UISlider</code> 等都是它的子类，也可以自定义 <code>UIControl</code>。通过  <code>addTarget(_:action:for:)</code> 指定响应事件和对象和方法，如果 <code>target</code> 为 <code>nil</code>，则按照响应链传递该事件。</p>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">beginTracking</span>(<span class="keyword">_</span> <span class="params">touch</span>: <span class="type">UITouch</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">continueTracking</span>(<span class="keyword">_</span> <span class="params">touch</span>: <span class="type">UITouch</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">endTracking</span>(<span class="keyword">_</span> <span class="params">touch</span>: <span class="type">UITouch</span>?, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) <span class="comment">// touch is sometimes nil if cancelTracking calls through to this.</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">cancelTracking</span>(<span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) <span class="comment">// event may be nil if cancelled for non-event reasons, e.g. removed from window</span></span><br></pre></td></tr></table></div></figure>

<p>与 <code>UIResponder</code> 类似，<code>UIControl</code> 有 4 种跟踪触摸事件的方法，分别与 <code>UIResponder</code> 的 <code>began</code>、<code>moved</code>、<code>ended</code>、<code>cancelled</code> 相对应。如果查看其调用栈，可以发现在 <code>UIResponder</code> 方法内部调用了 <code>UIControl</code> 的跟踪方法。</p>
<p><img src="/images/blog/image-20220707113956921.png" alt="image-20220707113956921"></p>
<p>如果在响应事件的方法打断点，查看调用栈帧，会发现 <code>UIControl</code> 会首先将事件通过 <code>sendAction:to:forEvent:</code> 发送给 <code>UIApplication</code>，再通过 <code>sendAction</code> 转发给发送的对象的对象。</p>
<p><img src="/images/blog/image-20220707114606464.png" alt="image-20220707114606464"></p>
<p>与 <code>UIGestureRecognizer</code> 相比，事件仍会优先传递到 <code>UIGestureRecognizer</code>，这一点可以重写 <code>UIGestureRecognizer</code> 的 4 个响应方法验证。</p>
<p>如果 <code>UIControl</code> 是其子视图，会判断其是否为系统默认控件，系统默认控件则优先响应 <code>UIControl</code> 的 <code>action</code> 方法，如果为自定义控件，则默认优先响应 <code>UIGestureRecognizer</code> 的 <code>action</code>。值得注意的是，如果将 <code>UIGestureRecognizer</code> 的 <code>cancelsTouchesInView</code> 改为<code> false</code>(默认为 <code>true</code>)，则发现 <code>UIGestureRecognizer</code> 也会进行响应，个人理解为 <code>cancelsTouchesInView</code> 改变了响应互斥的特性，因此本身也会响应。 </p>
<p>如果 <code>UIControl</code> 为父视图或平级视图，由于仍会优先将事件传递到 <code>UIGestureRecognizer</code>， 则可以根据其 <code>cancelsTouchesInView</code>、<code>delaysTouchesBegan</code>、<code>delaysTouchesEnded</code> 判断事件能否传递到 <code>UIControl</code>，这一点 <code>UIControl</code> 与 <code>UIResponder</code> 一致。</p>

        <h3 id="应用实践"   >
          <a href="#应用实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h3>
      
        <h4 id="扩大响应区域"   >
          <a href="#扩大响应区域" class="heading-link"><i class="fas fa-link"></i></a><a href="#扩大响应区域" class="headerlink" title="扩大响应区域"></a>扩大响应区域</h4>
      <ol>
<li>重写本视图的 <code>func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool</code> </li>
</ol>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">point</span>(<span class="params">inside</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// 将响应区域扩大 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.bounds.in<span class="keyword">set</span>(by: .<span class="keyword">init</span>(top: <span class="operator">-</span><span class="number">30</span>, left: <span class="operator">-</span><span class="number">30</span>, bottom: <span class="operator">-</span><span class="number">30</span>, right: <span class="operator">-</span><span class="number">30</span>)).contains(point)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li>重写父视图的 <code>func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView?</code></li>
</ol>
<figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">hitTest</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) -&gt; <span class="type">UIView</span>? &#123;</span><br><span class="line">    <span class="comment">// 将响应区域扩大 30</span></span><br><span class="line">    <span class="comment">// subView 为应扩大响应区域的视图</span></span><br><span class="line">    <span class="keyword">if</span> subView.frame.in<span class="keyword">set</span>(by: .<span class="keyword">init</span>(top: <span class="operator">-</span><span class="number">30</span>, left: <span class="operator">-</span><span class="number">30</span>, bottom: <span class="operator">-</span><span class="number">30</span>, right: <span class="operator">-</span><span class="number">30</span>)).contains(point) &#123;</span><br><span class="line">        <span class="keyword">return</span> subView</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hitTest(point, with: event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="根据触摸实时修改-view-位置"   >
          <a href="#根据触摸实时修改-view-位置" class="heading-link"><i class="fas fa-link"></i></a><a href="#根据触摸实时修改-view-位置" class="headerlink" title="根据触摸实时修改 view 位置"></a>根据触摸实时修改 view 位置</h4>
      <figure class="highlight swift"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">touchesMoved</span>(<span class="keyword">_</span> <span class="params">touches</span>: <span class="type">Set</span>&lt;<span class="type">UITouch</span>&gt;, <span class="params">with</span> <span class="params">event</span>: <span class="type">UIEvent</span>?) &#123;</span><br><span class="line">    <span class="keyword">let</span> touch <span class="operator">=</span> touches.randomElement()</span><br><span class="line">    <span class="keyword">let</span> prePoint <span class="operator">=</span> touch<span class="operator">?</span>.precisePreviousLocation(in: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> currPoint <span class="operator">=</span> touch<span class="operator">?</span>.location(in: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> prePoint <span class="operator">=</span> prePoint, <span class="keyword">let</span> currPoint <span class="operator">=</span> currPoint &#123;</span><br><span class="line">        <span class="keyword">let</span> offsetX <span class="operator">=</span> currPoint.x <span class="operator">-</span> prePoint.x</span><br><span class="line">        <span class="keyword">let</span> offsetY <span class="operator">=</span> currPoint.y <span class="operator">-</span> prePoint.y</span><br><span class="line">        <span class="keyword">self</span>.transform <span class="operator">=</span> <span class="keyword">self</span>.transform.translatedBy(x: offsetX, y: offsetY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="🔗"   >
          <a href="#🔗" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔗" class="headerlink" title="🔗"></a>🔗</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events" >Using Responders and the Responder Chain to Handle Events</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/c294d1bd963d" >iOS 触摸事件全家桶</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uigesturerecognizer?language=objc" >Apple - UIGestureRecognizer</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://southpeak.github.io/2015/12/13/cocoa-uikit-uicontrol/" >UIKit: UIControl</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://xuhaodong1.github.io">nihao</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://xuhaodong1.github.io/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/">https://xuhaodong1.github.io/2022/07/08/iOS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://xuhaodong1.github.io/tags/UI/">UI</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2022/06/01/debugging_in_xcode/"><span class="paginator-prev__text">Xcode 中的调试技巧</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">
          前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%80%85-amp-%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE"><span class="toc-number">2.</span> <span class="toc-text">
          响应者 &amp; 响应者链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-amp-%E8%B0%81%E6%98%AF%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%AC%AC%E4%B8%80%E5%93%8D%E5%BA%94%E8%80%85"><span class="toc-number">3.</span> <span class="toc-text">
          事件 &amp; 谁是事件的第一响应者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">
          触摸事件流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BD%B3%E5%93%8D%E5%BA%94%E8%80%85"><span class="toc-number">4.1.</span> <span class="toc-text">
          寻找最佳响应者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.</span> <span class="toc-text">
          触摸事件的响应以及传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UIGestureRecognizer"><span class="toc-number">4.2.1.</span> <span class="toc-text">
          UIGestureRecognizer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UIControl"><span class="toc-number">4.2.2.</span> <span class="toc-text">
          UIControl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.3.</span> <span class="toc-text">
          应用实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%A4%A7%E5%93%8D%E5%BA%94%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          扩大响应区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%A7%A6%E6%91%B8%E5%AE%9E%E6%97%B6%E4%BF%AE%E6%94%B9-view-%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          根据触摸实时修改 view 位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%97"><span class="toc-number">5.</span> <span class="toc-text">
          🔗</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">不以功利为目的.</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xuhaodong1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://xuhaodong1.github.io/images/wechat.jpeg" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021~2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>nihao201</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.2</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>function loadUtterances() {
  var d = document, s = d.createElement('script');
  var container = d.getElementById('utterances-container');

  if (!container) {
    return;
  }
  s.src = 'https://utteranc.es/client.js';
  s.setAttribute('repo', 'xuhaodong1/xuhaodong1.github.io');
  s.setAttribute('issue-term', 'title');
  s.setAttribute('label', 'utterances');
  s.setAttribute('theme', 'github-light');
  s.setAttribute('crossorigin', 'anonymous');
  s.setAttribute('async', '');
  if (false) {
    s.setAttribute('data-pjax-rm', '');
  }
  container.append(s);
}

if (false) {
  loadUtterances();
} else {
  window.addEventListener('DOMContentLoaded', loadUtterances, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>